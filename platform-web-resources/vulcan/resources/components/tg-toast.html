<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/polymer/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="/resources/polymer/paper-styles/color.html">

<link rel="import" href="/resources/polymer/paper-button/paper-button.html">
<link rel="import" href="/resources/polymer/paper-dialog/paper-dialog.html">
<link rel="import" href="/resources/polymer/paper-toast/paper-toast.html">
<link rel="import" href="/resources/polymer/paper-spinner/paper-spinner.html">

<link rel="import" href="/resources/reflection/tg-polymer-utils.html">

<!-- <core-style id="toast-progress-indicator">
    paper-spinner { position: absolute; top: 9px; right: 9px; padding: 0px; margin: 0px;}

    paper-spinner.blue::shadow .circle { border-color: {{g.paperInput.focusedColor}}; }
</core-style> -->

<style is="custom-style">
    .paper-toast {
        @apply(--layout-horizontal);
        @apply(--layout-center);
        max-width: 256px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-smooth: always;
    }
    .more {
        padding-left: 8px;
        color: #03A9F4;
        font-weight: 800;
        font-smooth: always;
        cursor: pointer;
    }
    /* style to truncate the toast text */
    body /deep/ paper-toast::shadow #label {
        @apply(--layout-flex);
        max-width: 248px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .toast-dialog paper-button {
        color: var(--paper-light-blue-500);
        --paper-button-flat-focus-color: var(--paper-light-blue-50);
    }
    .toast-dialog paper-button:hover {
        background: var(--paper-light-blue-50);
    }
    #toast paper-spinner {
        width: 1.5em;
        height: 1.5em;
        min-width: 1em;
        min-height: 1em;
        max-width: 2em;
        max-height: 2em;
        padding: 2px;
        margin-left: 1em;
        --paper-spinner-layer-1-color: var(--paper-blue-500);
        --paper-spinner-layer-2-color: var(--paper-blue-500);
        --paper-spinner-layer-3-color: var(--paper-blue-500);
        --paper-spinner-layer-4-color: var(--paper-blue-500);
    }
</style>

<dom-module id="tg-toast">
    <template>
        <paper-toast id="toast" class="paper-toast" text="[[_text]]" on-tap="_showMoreIfPossible" always-on-top duration="0">
            <!-- TODO responsive-width="250px" -->
            <paper-spinner id="spinner" hidden$="[[_skipShowProgress]]" active alt="in progress..." tabIndex="-1"></paper-spinner>
            <div id='btnMore' hidden$="[[_skipShowMore(_showProgress, _hasMore)]]" class="more" on-tap="_showMessageDlg">MORE</div>
        </paper-toast>
    </template>
</dom-module>

<script>
    (function () {
        const PROGRESS_DURATION = 3600000; //1 hour
        const CRITICAL_DURATION = 5000; //5 seconds
        const MORE_DURATION = 4000; //4 seconds
        const STANDARD_DURATION = 2000; //2 seconds

        function containsRestictedTags(htmlText) {
            const offensiveTag = new RegExp('<html|<body|<script|<img|<a', 'mi');
            return offensiveTag.exec(htmlText) !== null;
        }

        Polymer({
            // attributes="msgHeading -- TODO was this ever needed?"

            is: 'tg-toast',

            properties: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////// EXTERNAL PROPERTIES //////////////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                // These mandatory properties must be specified in attributes, when constructing descendant elements.  //
                // No default values are allowed in this case.														   //
                /////////////////////////////////////////////////////////////////////////////////////////////////////////

                text: {
                    type: String
                },

                msgText: {
                    type: String,
                    value: ''
                },

                showProgress: {
                    type: Boolean
                },

                hasMore: {
                    type: Boolean
                },

                isCritical: {
                    type: Boolean,
                    value: false
                },
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                //////////////////////////////// INNER PROPERTIES, THAT GOVERN CHILDREN /////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                // These properties derive from other properties and are considered as 'private' -- need to have '_'   //
                //   prefix. 																				           //
                // Also, these properties are designed to be bound to children element properties -- it is necessary to//
                //   populate their default values in ready callback (to have these values populated in children)!     //
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                _text: {
                    type: String
                },

                _msgText: {
                    type: String,
                    value: ''
                },

                _showProgress: {
                    type: Boolean
                },

                _hasMore: {
                    type: Boolean,
                    observer: '_hasMoreChanged'
                },

                _isCritical: {
                    type: Boolean,
                    value: false
                },

                _skipShowProgress: {
                    type: Boolean,
                    computed: '_shouldSkipProgress(_showProgress, _hasMore)'
                }
            },

            ready: function () {
                //Indicates whether toast overlay can be closed via history (back button or not)
                this.$.toast.skipHistoryAction = true;
            },

            _hasMoreChanged: function (newValue, oldValue) {
                // let's set a cursor for the whole toast if it can be "clicked"
                const cursor = newValue === true ? 'pointer' : 'inherit';
                this.$.toast.style.cursor = cursor;
            },

            _showMoreIfPossible: function (e) {
                if (this._hasMore) {
                    this._showMessageDlg(e);
                }
            },

            _showMessageDlg: function (event) {
                const self = this;
                // need to open dialog asynchronously for it to open on mobile devices
                this.async(function () {
                    // build and display the dialog
                    const domBind = document.createElement('template', 'dom-bind');

                    domBind._dialogClosed = function () {
                        Polymer.dom(document.body).removeChild(this);
                        Polymer.dom.flush();
                    }.bind(domBind);

                    const paperDialog = domBind.content.ownerDocument.createElement('paper-dialog');
                    Polymer.dom(paperDialog).setAttribute("class", "toast-dialog");
                    Polymer.dom(paperDialog).setAttribute("id", "msgDialog");
                    Polymer.dom(paperDialog).setAttribute("on-iron-overlay-closed", "_dialogClosed");
                    Polymer.dom(paperDialog).setAttribute("with-backdrop", "true");
                    Polymer.dom(paperDialog).setAttribute("entry-animation", "scale-up-animation");
                    Polymer.dom(paperDialog).setAttribute("exit-animation", "fade-out-animation");

                    const paperDialogScrollable = domBind.content.ownerDocument.createElement('paper-dialog-scrollable');
                    const msgPar = domBind.content.ownerDocument.createElement('p');
                    Polymer.dom(msgPar).setAttribute("style", "padding: 10px");
                    if (containsRestictedTags(this._msgText) === true) {
                        Polymer.dom(msgPar).textContent = this._msgText;
                    } else {
                        Polymer.dom(msgPar).innerHTML = this._msgText;
                    }
                    Polymer.dom(paperDialogScrollable).appendChild(msgPar);

                    const buttonsDiv = domBind.content.ownerDocument.createElement('div');
                    Polymer.dom(buttonsDiv).setAttribute("class", "buttons");

                    const buttons = domBind.content.ownerDocument.createElement('paper-button');
                    Polymer.dom(buttons).setAttribute("dialog-confirm", "dialog-confirm");
                    Polymer.dom(buttons).setAttribute("affirmative", "affirmative");
                    Polymer.dom(buttons).setAttribute("autofocus", "autofocus");

                    const textSpan = domBind.content.ownerDocument.createElement('span');
                    Polymer.dom(textSpan).textContent = 'Close';
                    Polymer.dom(buttons).appendChild(textSpan);

                    Polymer.dom(buttonsDiv).appendChild(buttons);

                    Polymer.dom(paperDialog).appendChild(paperDialogScrollable);
                    Polymer.dom(paperDialog).appendChild(buttonsDiv);

                    Polymer.dom(domBind.content).appendChild(paperDialog);
                    Polymer.dom(document.body).appendChild(domBind);
                    Polymer.dom.flush();

                    this.async(function () {
                        domBind.$.msgDialog.open();
                    }, 100);

                    self.$.toast.close();
                }, 100);

                tearDownEvent(event);
            },

            _shouldSkipProgress: function (progress, hasMore) {
                return !progress || hasMore;
            },

            _skipShowMore: function (progress, hasMore) {
                return progress || !hasMore;
            },
            
            _getPreviousToast() {
                var toasts = document.querySelectorAll('#toast');
                var toast = null;
                var existingToastCount = 0;
                for (var index = 0; index < toasts.length; index++) {
                    var currToast = toasts.item(index);
                    if (currToast.parentNode === document.body) {
                        existingToastCount++;
                        if (existingToastCount > 1) {
                            throw 'More than one toast exist in body direct children.';
                        }
                        toast = currToast;
                    }
                }
                return toast;
            },
            
            show: function () {
                const previousToast = this._getPreviousToast();
                if (!previousToast) {
                    // initial values
                    this.$.toast.error = false;
                    this.$.toast._autoCloseCallBack = null; // must NOT interfere with _autoClose of paper-toast
                    // Override refit function for paper-toast which behaves really weird (Maybe next releas of paper-toast iron-fit-behavior and iron-overlay-behavior will change this weird behaviour).
                    this.$.toast.refit = function () {};
                    Polymer.dom(document.body).appendChild(this.$.toast);
                    Polymer.dom().flush();
                    this._showNewToast();
                } else if (previousToast.error === true && previousToast.opened && this.isCritical === false) { // discard new toast if existing toast is critical and new one is not; however if new one is critical -- do not discard it -- show overridden information
                    console.warn('    toast show: DISCARDED: text = ', this.text + ', critical = ' + this.isCritical);
                } else {
                    // 'dataHost' is used to detemine 'tg-toast' instance from 'previousToast' found on body (parent of 'previousToast' is body, that is why there is a need to use other accessing method).
                    // WARNING: 'dataHost' is not a public Polymer API.
                    const previousTgToast = previousToast.dataHost;
                    
                    if (previousTgToast !== this) {
                        previousTgToast.text = this.text;
                        previousTgToast.msgText = this.msgText;
                        previousTgToast.showProgress = this.showProgress;
                        previousTgToast.hasMore = this.hasMore;
                        previousTgToast.isCritical = this.isCritical;
                    }
                    previousTgToast._showNewToast();
                }
            },
            
            _showNewToast: function () {
                this._text = this.text;
                this._msgText = this.msgText;
                this._showProgress = this.showProgress;
                this._hasMore = this.hasMore;
                this._isCritical = this.isCritical;
                
                let customDuration;
                if (this._showProgress && !this._hasMore) {
                    customDuration = PROGRESS_DURATION;
                } else if (this._isCritical === true) {
                    customDuration = CRITICAL_DURATION;
                } else if (this._hasMore === true) {
                    customDuration = MORE_DURATION;
                } else {
                    customDuration = STANDARD_DURATION;
                }
                if (this._isCritical === true || this.$.toast.error === false) { // if critical toast arrived then delay its closing; also delay closing if toast is not critical but old toast is not critical too
                    if (this.$.toast._autoCloseCallBack !== null) {
                        this.$.toast.cancelAsync(this.$.toast._autoCloseCallBack);
                        this.$.toast._autoCloseCallBack = null;
                    }
                    this.$.toast._autoCloseCallBack = this.$.toast.async(this._closeToast.bind(this), customDuration);
                }
                
                this.$.toast.error = this._isCritical;
                if (this._isCritical === true) {
                    this.$.toast.style.background = '#D50000';
                    this.$.btnMore.style.color = '#FFCDD2';
                } else {
                    this.$.toast.style.background = 'black';
                    this.$.btnMore.style.color = '#03A9F4';
                }
                this.$.toast.show();
            },
            
            _closeToast: function () {
                this.$.toast.close();
                this.$.toast._autoCloseCallBack = null;
            }
        })
    })();
</script>
</polymer-element>
