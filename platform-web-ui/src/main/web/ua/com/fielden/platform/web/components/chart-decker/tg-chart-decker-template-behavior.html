<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/app/tg-app-config.html">

<link rel="import" href="/resources/master/tg-entity-master-template-behavior.html">
<link rel="import" href="/resources/reflection/tg-polymer-utils.html">

<script>
    (function () {

        const generateActionTooltip = function (action) {
            const shortDesc = "<b>" + action.shortDesc + "</b>";
            if (action.shortDesc) {
                longDesc = action.longDesc ? "<br>" + action.longDesc : "";
            } else {
                longDesc = action.longDesc ? "<b>" + action.longDesc + "</b>" : "";
            }
            var tooltip = shortDesc + longDesc;
            return tooltip && "<div style='display:flex;'>" +
                "<div style='margin-right:10px;'>With action: </div>" +
                "<div style='flex-grow:1;'>" + tooltip + "</div>" +
                "</div>"
        };

        Polymer.TgBehaviors = Polymer.TgBehaviors || {};
        Polymer.TgBehaviors.TgChartDeckerTemplateBehaviorImpl = {

            properties: {
                actions: Array,
                charts: Array,
                centreSelection: {
                    type: Object,
                    observer: "_centreSelectionChanged"
                }
            },

            ready: function () {
                this.appConfig = document.createElement("tg-app-config");
                this.actions = this._masterDom().querySelectorAll(".chart-action");
                this.charts = this._masterDom().querySelectorAll(".chart-deck");
                this._chartLeftMargins = [];
                this.charts.forEach((chart, index) => {
                    chart.addEventListener("bar-entity-selected", this._entitySelectedListener.bind(this));
                    chart.addEventListener("y-axis-label-positioned", this._alignCharts(index))
                });
            },

            _alignCharts: function (index) {
                return function (event) {
                    if (!this._chartLeftMargins[index]) {
                        this._chartLeftMargins[index] = event.detail;
                        let allDefined = true;
                        this.charts.forEach((chart, index) => {
                            if (!this._chartLeftMargins[index]) {
                                allDefined = false;
                            }
                        });
                        if (allDefined) {
                            const maxLeftMargin = Math.max.apply(null, this._chartLeftMargins);
                            if (!this._lastLeftMargin || maxLeftMargin !== this._lastLeftMargin) {
                                this._lastLeftMargin = maxLeftMargin;
                                this.charts.forEach(chart => chart.options = {
                                    margin: {
                                        left: this._lastLeftMargin
                                    }
                                });
                            }
                            this._chartLeftMargins = [];
                        }
                    }
                }.bind(this);
            },

            _entitySelectedListener: function (event) {
                const target = this.customEventTarget || this;
                target.fire("tg-entity-selected", event.detail);
                tearDownEvent(event);
            },

            _moneyPropAccessor: function (propertyName) {
                return function (entity, value) {
                    if (!value) {
                        return entity.get(propertyName).amount;
                    }
                }.bind(this);
            },

            _labelFormatter: function (propertyNames, propertyTypes) {
                return function (entity, idx) {
                    return this._getValue(entity, property, type);
                }.bind(this);
            },

            _tooltip: function (groupProperty, aggregationProperty, type, action) {
                return function (entity) {
                    const valueTooltip = this._getValue(entity, aggregationProperty, type, mode);
                    const groupTooltip = entity.get(groupProperty);
                    const actionTooltip = action ? generateActionTooltip(action) : "";
                    let tooltip = valueTooltip ? "<b>" + valueTooltip + "</b>" : "";
                    tooltip += (groupTooltip && tooltip && "<br>") + groupTooltip;
                    tooltip += (actionTooltip && tooltip && "<br><br>") + actionTooltip;
                    return tooltip;
                }.bind(this);
            },

            _click: function (chartIndex) {
                return function (entity) {
                    this.actions[chartIndex].currentEntity = entity;
                    this.actions[chartIndex]._run();
                }.bind(this);
            },

            _getValue: function (entity, property, type) {
                if (typeof entity.get(property) === 'number') {
                    if (type === 'BigDecimal') {
                        const metaProp = this._reflector().getEntityTypeProp(entity, property);
                        return this._reflector().formatDecimal(entity.get(property), this.appConfig.locale, metaProp && metaProp.scale(), metaProp && metaProp.trailingZeros());
                    } else {
                        return this._reflector().formatNumber(entity.get(property), this.appConfig.locale);
                    }
                } else if (type === 'Money') {
                    const metaProp = this._reflector().getEntityTypeProp(entity, property);
                    return this._reflector().formatMoney(entity.get(property), this.appConfig.locale, metaProp && metaProp.scale(), metaProp && metaProp.trailingZeros());
                }
            },

            _centreSelectionChanged: function (newSelection, oldSelection) {
                newSelection.entities.forEach(selectionEntity => this.selectChartEntity(selectionEntity.entity, selectionEntity.select));
            },

            selectChartEntity: function (entity, select) {
                this.charts.forEach(chart => chart.selectEntity(entity, select));
            }

        };

        Polymer.TgBehaviors.TgChartDeckerTemplateBehavior = [
            Polymer.TgBehaviors.TgEntityMasterTemplateBehavior,
            Polymer.TgBehaviors.TgChartDeckerTemplateBehaviorImpl
        ];

    })();
</script>