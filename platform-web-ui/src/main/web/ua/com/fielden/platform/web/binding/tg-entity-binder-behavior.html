<link rel="import" href="/resources/polymer/polymer/polymer.html">

<script>
    (function () {
    	Polymer.TgBehaviors = Polymer.TgBehaviors || {};
    	Polymer.TgBehaviors.TgEntityBinderBehavior = {
    			
    		properties: {
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	////////////////////////////////////////// EXTERNAL PROPERTIES //////////////////////////////////////////
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	// These mandatory properties must be specified in attributes, when constructing descendant elements.  //
            	// No default values are allowed in this case.														   //
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	
            	/**
            	 * The id of the currently bound entity (or 'new' in case of entity without id, aka 'not yet persisted' one, or 'find_or_new' in case of one-2-one associations).
            	 *
            	 * Sets initially during tg-entity-binder (master or selection criteria) generation phase and then updates accordingly.
            	 */
            	entityId: {
            		type: String
            	},
            	
                /**
                 * The state for the entity master.
                 *
                 * The master can be only in two states: EDIT and VIEW. The state EDIT
                 * allows user to edit properties and use some actions (as it was defined in Java API with 'enabledWhen').
                 *
                 * The state VIEW allows user to review the entity properties and do some actions (as it was defined in
                 * Java API with 'enabledWhen').
                 *
                 * The initial state can be VIEW or EDIT.
                 */
                currentState: {
                	type: String
                    // reflectToAttribute: true -- why is this needed?
                },
                
                /**
                 * Universal identifier of this element instance (used for pub / sub communication).
                 *
                 * It is either assigned from the outside or could be defined internally. 
                 * For example, entity masters have this property assigned in their ready callback, which can be replaced later with a different value if required.
                 *
                 * Property observer is used to report value changes in case one needs to chase undesired assignment side-effect.
                 */
                uuid: {
                	type: String,
                	observer: "_uuidChanged"
                },
                
                /**
                 * Custom callback that will be invoked after successfull retrieval / deserialisation and before actual promotion of the entity to the entity binder.
                 *
                 * This function-property should be mainly used for testing. That is why default function-property value is set -- it does just nothing.
                 *
                 * arguments: entity
                 */
                preRetrieved: {
                	type: Function,
                	value: function () {
                		return function (entity) {
                            return entity;
                        };
                	}
                },
                
                /**
                 * Custom callback that will be invoked after successfull retrieval.
                 *
                 * arguments: entity, bindingEntity, customObject
                 */
                postRetrieved: {
                	type: Function
                },
                
                /**
                 * Custom callback that will be invoked in case retrieval fails.
                 *
                 * arguments: errorResult
                 */
                postRetrievedError: {
                	type: Function
                },
                
                /**
                 * Custom callback that will be invoked after successfull validation.
                 *
                 * arguments: validatedEntity, bindingEntity, customObject
                 */
                postValidated: {
                	type: Function
                },
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	//////////////////////////////////////////// INNER PROPERTIES ///////////////////////////////////////////
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	// These properties derive from other properties and are considered as 'private' -- need to have '_'   //
            	//   prefix and default values specified in 'value' specificator of the property definition (or,       //
            	//   alternatively, computing function needs to be specified). 									       //
            	/////////////////////////////////////////////////////////////////////////////////////////////////////////
            	
            	/**
            	 * The current fully-fledged entity, that is used to create '_currBindingEntity' and '_originalBindingEntity'.
            	 */
  	            _currEntity: {
  	            	type: Object,
  	            	value: null
  	            },
  	            
  	            /**
  	             * Represents the view of original entity for binding.
  	             */
  	            _originalBindingEntity: {
  	            	type: Object,
  	            	value: null
  	            },

             	/////////////////////////////////////////////////////////////////////////////////////////////////////////
             	//////////////////////////////// INNER PROPERTIES, THAT GOVERN CHILDREN /////////////////////////////////
             	/////////////////////////////////////////////////////////////////////////////////////////////////////////
             	// These properties derive from other properties and are considered as 'private' -- need to have '_'   //
             	//   prefix. 																				           //
             	// Also, these properties are designed to be bound to children element properties -- it is necessary to//
             	//   populate their default values in ready callback (to have these values populated in children)!     //
             	/////////////////////////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Represents the view of current entity for binding.
                 */
                _currBindingEntity: {
                	type: Object
                },
                
                /**
                 * This modif holder is needed for lazy value conversion in concrete editors.
                 */
                _previousModifiedPropertiesHolder: {
                    type: Object
                },
                
                /**
                 * Returns true in case where binding entity has modified properties, false otherwise.
                 * 
                 * Please, note that this property recomputes and caches manually strictly when _currBindingEntity and _originalBindingEntity changes (_postEntityReceived method).
                 *
                 * Also, invalid entity value will be 'modified', even though the entities from server arrive with valid value only (+invalid validation result). 
                 * Client-side logic handles this gracefully in method _extractBindingView(entity, previousModifiedPropertiesHolder, prevCurrBindingEntity).
                 * 
                 * This property can not be used in tg-selection-criteria-behavior due to the fact that it will be isModified from previous, not from original version of centre.
                 * Currently _centreChanged property is used (see tg-entity-centre-behavior and tg-selection-criteria-behavior).
                 */
                _bindingEntityModified: {
                    type: Boolean,
                    observer: '_bindingEntityModifiedChanged'
                },
                
                /**
                 * Returns indication whether SAVE button should be enabled for the entity (AND canClose should be false). Returns true in following cases:
                 *
                 * 1) the entity is not persistent (SAVE is enabled always, can not close, only through SAVE / CANCEL buttons);
                 * 2) the entity is persistent but is not persisted yet (SAVE is enabled always, can not close, only through SAVE / CANCEL buttons);
                 * 3) the entity is persistent, is persisted but and it is modified (SAVE is enabled always, can not close, only through SAVE / CANCEL buttons).
                 *
                 * Please, note that this property (analogously to _bindingEntityModified) recomputes and caches manually strictly when _currBindingEntity and _originalBindingEntity changes (_postEntityReceived method).
                 */
                _bindingEntityNotPersistentOrNotPersistedOrModified: {
                    type: Boolean,
                    observer: '_bindingEntityNotPersistentOrNotPersistedOrModifiedChanged'
                },

                /**
                 * '_createModifiedPropertiesHolder' function, that is designated for binding.
                 */
                _createModifiedPropertiesHolder: {
                	type: Function
                },
                
                /**
                 * Default implementation for postValidated callback.
                 */
                _postValidatedDefault: {
                	type: Function
                },
                
                /**
                 * Default implementation for unsuccessful postValidated callback.
                 */
                _postValidatedDefaultError: {
                	type: Function
                },
                
                /**
                 * Default implementation for postRetrieved callback.
                 */
                _postRetrievedDefault: {
                	type: Function
                },
                
                /**
                 * Default implementation for unsuccessful postRetrieved callback.
                 */
                _postRetrievedDefaultError: {
                	type: Function
                },
                
                /**
                 * Default implementation for unsuccessful postSearched callback.
                 */
                _postSearchedDefaultError: {
                	type: Function
                },
                
                /**
                 * This is the standard processor for 'core-response's and is applicable for all
                 *   responses that contain java Result inside 'e.detail.response'.
                 *
                 * In case when result is not successful (i.e. has 'ex' inside) the toast message is shown 
                 *   and 'customErrorHandlerFor(result)' is invoked.
                 *
                 * In case when result is successful -- 'customHandlerFor(result.instance)' is invoked.
                 *
                 *
                 * This is the function, that is designated for binding.
                 */
                _processResponse: {
                	type: Function
                },
                
                /**
                 * This is the standard processor for 'core-response's and is applicable for all
                 *   responses that contain java Result inside 'e.detail.response'.
                 *
                 * In case when result is not successful (i.e. has 'ex' inside) the toast message is shown 
                 *   and 'customErrorHandlerFor(result)' is invoked.
                 *
                 * In case when result is successful -- 'customHandlerFor(result.instance)' is invoked.
                 *
                 *
                 * This is the function, that is designated for binding.
                 */
                _processError: {
                	type: Function
                },
                
                /**
                 * Starts the process of entity validation (based on _currBindingEntity).
                 *
                 * This function is designated for binding.
                 */
                validate: {
                	type: Function
                },
                
                /**
                 * The function that explicitly says that validation is skipped.
                 *
                 * This function is designated for binding.
                 */
                doNotValidate: {
                	type: Function
                },
                
                /**
                 * Starts the process of entity retrieval (based on current entityId).
                 *
                 * This function is designated for binding.
                 */
                retrieve: {
                	type: Function
                },
                
                /**
                 * Layout configuration (desktop) for this binder content (editors in case of 'tg-entity-master', criteria in case of 'tg-entity-centre').
                 */
                _desktopLayout: {
                	type: Array
                },
                
                /**
                 * Layout configuration (tablet) for this binder content (editors in case of 'tg-entity-master', criteria in case of 'tg-entity-centre').
                 */
                _tabletLayout: {
                	type: Array
                },
                
                /**
                 * Layout configuration (mobile) for this binder content (editors in case of 'tg-entity-master', criteria in case of 'tg-entity-centre').
                 */
                _mobileLayout: {
                	type: Array
                },
                
                _disablementCounter: {
                    type: Number,
                    value: 0
                },
                
                _validationPromise: {
                    type: Object,
                    observer: '_validationPromiseChanged'
                },
                
                /**
                 * Returns true in case where there exist some properties which were edited (but not yet committed) by tg-editor-behavior.
                 */
                _editedPropsExist: {
                    type: Boolean
                }
    		},
    		
    		observers: [
    		    '_editedPropsChanged(_currBindingEntity.@editedProps)',
    		    '_modificationsChanged(_bindingEntityNotPersistentOrNotPersistedOrModified, _editedPropsExist)'
    		],
    		
    		_validationPromiseChanged: function (newValidationPromise, oldValidationPromise) {
    		},
    		_bindingEntityModifiedChanged: function (new_bindingEntityModified, old_bindingEntityModified) {
    		},
    		_bindingEntityNotPersistentOrNotPersistedOrModifiedChanged: function (newValue, oldValue) {
    		},
    		_modificationsChanged: function (_bindingEntityNotPersistentOrNotPersistedOrModified, _editedPropsExist) {
    		},
    		
    		_editedPropsChanged: function (editedProps) {
    		    this._editedPropsExist = typeof editedProps === 'undefined' ? false : Object.keys(editedProps).length !== 0;
    		    // console.debug('_bindingEntity (_editedPropsChanged) self = ', this.is, 'this.$._saveAction = ', (this.$._saveAction ? this.$._saveAction.is : 'undefined'), 'editedProps', editedProps, 'this._editedPropsExist', this._editedPropsExist);
    		},
    		
    		/**
    		 * Nullifies previously bound to this master entity in preparation to rebind a brand new instance. 
    		 */
    		_resetState: function () {
                this._currEntity = null;
                this._currBindingEntity = null;
                this._originalBindingEntity = null;
    		},
            
            /**
             * Initialisation block. It has all children web components already initialised.
             */
            ready: function () {
                var self = this;
                
                self._bindingEntityModified = false;
                self._bindingEntityNotPersistentOrNotPersistedOrModified = false;
                self._editedPropsExist = false;
                self._resetState();
                
                self._createModifiedPropertiesHolder = (function () {
	                var mph = this._extractModifiedPropertiesHolder(this._currBindingEntity, this._originalBindingEntity);
                    return this._reset(mph);
                }).bind(self);
                
                self._provideExceptionOccured = (function (entity, exceptionOccured) {
                    if (exceptionOccured !== null && this._reflector().isEntity(entity)) {
                        entity._setExceptionOccured(exceptionOccured);
                    }
                }).bind(self);
                
                self._processRetrieverResponse = function (e) {
                	self._processResponse(e, "retrieve", function (entityAndCustomObject, exceptionOccured) {
                	    self._provideExceptionOccured(entityAndCustomObject[0], exceptionOccured);
                		return self._postRetrievedDefault(entityAndCustomObject);
                	});
                };
                
                self._processRetrieverError = function (e) {
                	self._processError(e, "retrieve", function (errorResult) {
                        return self._postRetrievedDefaultError(errorResult);
                    });
                };
                
                self._processResponse = (function(e, name, customHandlerFor) {
                    console.log("PROCESS RESPONSE");
                	console.log(name, ": iron-response: status = ", e.detail.xhr.status, ", e.detail.response = ", e.detail.response);
                    if (e.detail.xhr.status === 200) { // successful execution of the request
                        e.detail.successful = true;
                    	var deserialisedResult = this._serialiser().deserialise(e.detail.response);
                    	
                    	if (this._reflector().isWarning(deserialisedResult)) {
                    		console.warn(this._toastMsgForError(deserialisedResult));
                    		//this._openToastForError('Warning.', this._toastMsgForError(deserialisedResult));
                    	} else {
                    		// continue with normal handling of the result's instance
                    		var deserialisedInstance = deserialisedResult.instance;
                    		deserialisedResult.instance = null;
                    		// Need to open toast message in case where the top-level result is unsuccessful -- this message will be shown BEFORE 
                    		//   other messages about validation errors of 'deserialisedInstance' or '... completed successfully'.
                    		// Current logic of tg-toast will discard all other messages after this message, until this message dissapear.
                    	    if (this._reflector().isError(deserialisedResult)) {
                        	    this._openToastForError(deserialisedResult.message, this._toastMsgForError(deserialisedResult));
                        	}
    	                    e.detail.successful = customHandlerFor(deserialisedInstance, this._reflector().isError(deserialisedResult) ? deserialisedResult : null);
                    	    if (this._reflector().isError(deserialisedResult)) {
                        	    e.detail.successful = false;
                        	}
                    		console.log('CUSTOM HANDLER FOR RETURNED', e.detail.successful);
                    		// in case of customHandlerFor not returning any result need to assign true to recognise event handling as successful by default
                    		if (e.detail.successful !== false) {
                    		    e.detail.successful = true;
                    		    if (typeof deserialisedInstance.id !== 'undefined') {
                    		    	e.detail.entityId = deserialisedInstance.id;
                    		    	e.detail.entityPersistent = deserialisedInstance.type().isPersistent();
                    		    	e.detail.entityContinuation = deserialisedInstance.type().isContinuation();
                    		    }
                    		}
                    	}
                    } else { // other codes
                    	var error = 'Request could not be dispatched.';
                        console.warn(error);
                        this._openToastForError(error, 'Most likely due to networking issues the request could not be dispatched to server. Please try again later.');
                        // this is equivalent to server side error
                        // threfore, this._postRetrievedDefaultError should be invoked
                        this._postRetrievedDefaultError(error);
                    }
                }).bind(self);
                
                self._processError = (function(e, name, customErrorHandlerFor) {
                    console.log("PROCESS ERROR", e.error);
                    var xhr = e.detail.request.xhr;
                    if (xhr.status === 500) { // internal server error, which could either be due to business rules or have some other cause due to a bug or db connectivity issue
                        var deserialisedResult = this._serialiser().deserialise(xhr.response);
                        
                        if (this._reflector().isError(deserialisedResult)) {
                            // throw the toast message about the server-side error
                            var msg = this._toastMsgForError(deserialisedResult);
                            this._openToastForError(this._reflector().exceptionMessage(deserialisedResult.ex), msg);
                            // continue with custom error handling of the error result
                            customErrorHandlerFor(deserialisedResult);
                        } else {
                            //throw new Error('Responses with status code 500 suppose to carry an error cause!');
                            customErrorHandlerFor('Responses with status code 500 suppose to carry an error cause!');
                        }
                    } else if (xhr.status === 403) { // forbidden!
                        // TODO should prompt for login in place...
                        this._openToastForError("Access denied.", "The current session has expired. Please login and try again.");
                        customErrorHandlerFor('Access denied');
                    } else { // other codes
                        // from what it could be observed, this siuation was occuring only in case of request cancellation...
                        // let's simply produce a console warning at this stage
                        console.warn('Response with status ' + xhr.status + ' is unexpected and will be ignored.');
                    }
                }).bind(self);
                
             	// calbacks, that will be bound by editor child elements:
                self.validate = (function () {
                	var slf = this;
                	
                	// it is extremely important to create 'holder' outside of the debouncing construction to create immutable data 
                	//   and pass it to debouncing function. The main reson for that is the following:
                	//     'slf._currBindingEntity' instance inside the debounced function can be altered by the results
                	//     of previous validations!
	                var holder = slf._extractModifiedPropertiesHolder(slf._currBindingEntity, slf._originalBindingEntity);
                	
                	// After the first 'validate' invocation arrives -- debouncer will wait 50 milliseconds
                	//   for the next 'validate' invocation, and if it arrives -- the recent one will become as active ( and 
                	//   again will start waiting for 50 millis and so on).
                	this.debounce('invoke-validation', function () {
	                    console.log("validate");
            	        // cancel the 'invoke-validation' debouncer if there is any active one:
            	        this.cancelDebouncer('invoke-validation');
                	    // cancel previous validation before starting new one! The results of previous validation are irrelevant!
                    	slf._validator().abortValidationIfAny();

        	            // IMPORTANT: no need to check whether the _hasModified(holder) === true -- because the error recovery should happen!
            	        // (if the entity was not modified -- _validate(holder) will start the error recovery process)
                    	slf._validationPromise = slf._validateForDescendants(slf._reset(holder));
                	}, 50);
                }).bind(self);
             	
                self.doNotValidate = (function () {
                    console.log("do not validate");
                }).bind(self);
                
                self.retrieve = (function (context) {
                    this.disableView();
                    // cancel previous validation before starting refreshing process!
                    this._validator().abortValidationIfAny();
                    
                	if (context) {
                        var ser = this._serialiser().serialise(context);
                        this._ajaxRetriever().body = JSON.stringify(ser);
                	} else {
                		this._ajaxRetriever().body = null;
                	}
                    return this._ajaxRetriever().generateRequest().completes;
                }).bind(self);
                
                // calbacks, that will potentially be augmented by tg-action child elements:
                // 				retrieval:
                self._postRetrievedDefault = (function (entityAndCustomObject) {
                	// console.timeEnd('actual-retrieval');
                    var entity = this.preRetrieved(entityAndCustomObject[0]);
                    var customObject = this._reflector().customObject(entityAndCustomObject);
                    
				    var msg = this._toastMsg("Refreshing", entity);
				    this._openToast(entity, msg, !entity.isValid() || entity.isValidWithWarning(), msg, false);

                    var newBindingEntity = this._postEntityReceived(entity, true);
                    
                    this._postRetrievedDefaultForDescendants(entity, newBindingEntity, customObject);
                    // custom external action
                    if (this.postRetrieved) {
	                    this.postRetrieved(entity, newBindingEntity, customObject);
                    }
                    
                    // console.timeEnd('criteria-entity-retrieval');
                    console.timeEnd('loading-all');
                    
                    this.enableView();
                    return true;
                }).bind(self);
                
                self._postRetrievedDefaultError = (function (errorResult) {
                	// This function will be invoked after server-side error appear.
                	// 'tg-action' will augment this function with its own '_afterExecution' logic (spinner stopping etc.).                	
                	console.warn("SERVER ERROR: ", errorResult);
                	
                	// custom external action
                	if (this.postRetrievedError) {
	                    this.postRetrievedError(errorResult);
                    }
                	this.enableView();
                }).bind(self);
             	// 				validation:
                self._postValidatedDefault = (function (entityAndCustomObject) {
                    var validatedEntity = entityAndCustomObject[0];
                    var customObject = this._reflector().customObject(entityAndCustomObject);
                	
                    var msg = this._toastMsg("Validation", validatedEntity);
                    if (!validatedEntity.isValid()) {
                        this._openToast(validatedEntity, msg, !validatedEntity.isValid() || validatedEntity.isValidWithWarning(), msg, false);
                    }
                    
                    // in case where _continuations property exists (only in tg-entity-master) there is a need to reset continuations (they become stale after any change in initiating entity)
                    if (typeof this._continuations === 'object') {
                        this._continuations = {};
                    }

                    var newBindingEntity = this._postEntityReceived(validatedEntity, false);
                    // custom external action
                    if (this.postValidated) {
                    	this.postValidated(validatedEntity, newBindingEntity, customObject);
                    }
                }).bind(self);
                
                self._postValidatedDefaultError = (function (errorResult) {
                	// This function will be invoked after server-side error appear.
                	// 'tg-action' will augment this function with its own '_afterExecution' logic (spinner stopping etc.).                	
                	console.warn("SERVER ERROR: ", errorResult);
                }).bind(self);

				// 				searching:
                self._postSearchedDefaultError = (function (errorResult) {
                	// This function will be invoked after server-side error appear.
                	// 'tg-action' will augment this function with its own '_afterExecution' logic (spinner stopping etc.).                	
                	console.warn("SERVER ERROR: ", errorResult);
                }).bind(this);
            },

            ///////////// toast related //////////////////
            /**
             * Opens the toast with some message and with indication whether progress is started.
             */
            _openToast: function (entity, toastMsg, hasMoreInfo, moreInfo, showProgress) {
                this._toastGreeting().text = toastMsg;
                this._toastGreeting().hasMore = hasMoreInfo;
                this._toastGreeting().msgText = moreInfo;
                this._toastGreeting().showProgress = showProgress;
                if (hasMoreInfo) {
                    if (!entity.isValid()) {
                    	// TODO is it still relevant? msgHeading
              			// TODO is it still relevant? msgHeading
      					// TODO is it still relevant? msgHeading
                        this._toastGreeting().msgHeading = "Error";
                    } else if (entity.isValidWithWarning()) {
                        this._toastGreeting().msgHeading = "Warning";
                    } else {
                        this._toastGreeting().msgHeading = "Info";
                    }
                }
                this._toastGreeting().show();
            },
            
            /**
             * Opens the toast with some message and with indication whether progress is started.
             */
            _openToastWithoutEntity: function (toastMsg, hasMoreInfo, moreInfo, showProgress) {
                this._toastGreeting().text = toastMsg;
                this._toastGreeting().hasMore = hasMoreInfo;
                this._toastGreeting().msgText = moreInfo;
                this._toastGreeting().showProgress = showProgress;
                if (hasMoreInfo) {
                    this._toastGreeting().msgHeading = "Info";
                }
                this._toastGreeting().show();
            },
            
            /**
             * The inner function for validation to be overridden in descendants (for e.g. context-dependent validation in tg-entity-master)
             */
            _validateForDescendants: function (preparedModifHolder) {
                return this._validator().validate(preparedModifHolder);
            },

            /**
             * Opens the toast with some error message including full 'moreInfo' message.
             */
            _openToastForError: function (toastMsg, moreInfo) {
                this._toastGreeting().text = toastMsg;
                if (moreInfo) {
                    this._toastGreeting().hasMore = true;
                    this._toastGreeting().msgText = moreInfo;
                }
                this._toastGreeting().showProgress = false;
            	// TODO is it still relevant? msgHeading
      			// TODO is it still relevant? msgHeading
				// TODO is it still relevant? msgHeading
             	this._toastGreeting().msgHeading = "Error";
                this._toastGreeting().show();
            },
            
            _toastMsgForError: function (errorResult) {
            	var ex = errorResult.ex;
            	return this._reflector().stackTrace(ex);
            },
            
            _toastMsgForErrorObject: function (errorObject) {            	
            	var stack = errorObject.stack;
            	return this._reflector().stackTraceForErrorObjectStack(stack);
            },
            
            _toastMsg: function (actionName, entity) {
                if (!entity.isValid()) {
                    return entity.firstFailure().message;
                } else if (entity.isValidWithWarning()) {
                    return entity.firstWarning().message;
                } else {
                    return actionName + " completed successfully.";
                }
            },
            //////////////////////////////////////////////
            
            /**
             * The component for entity serialisation.
             */
            _serialiser: function () {
                throw "_serialiser: not implemented";
            },

            /**
             * The core-ajax component for entity retrieval.
             */
            _ajaxRetriever: function () {
                throw "_ajaxRetriever: not implemented";
            },

            /**
             * The tg-entity-validator component for entity validation.
             */
            _validator: function () {
                throw "_validator: not implemented";
            },
            
            /**
             * The reflector component.
             */
            _reflector: function () {
                throw "_reflector: not implemented";
            },
            
            /**
             * The toast component.
             */
            _toastGreeting: function () {
                throw "_toastGreeting: not implemented";
            },

            //////////////////////////////////////// RETRIEVAL ////////////////////////////////////////
            /**
             * This callback is intended to be invoked just before the custom 'postRetrieved' callback.
             * Override it in descendants to provide some custom behaviour.
             */
            _postRetrievedDefaultForDescendants: function(entity, newBindingEntity, customObject) {
            },
            
            //////////////////////////////////////// VALIDATION ////////////////////////////////////////
            _reset: function (modifiedPropertiesHolder) {
                delete modifiedPropertiesHolder['@modified']; // remove it not to serialise this purely technical property
                return modifiedPropertiesHolder;
            },

            _extractModifiedPropertiesHolder: function (bindingEntity, _originalBindingEntity) {
                var modPropHolder = {
                    "@modified": false
                };
                var self = this;
                if (self._reflector().isEntity(bindingEntity)) {
                    modPropHolder["id"] = bindingEntity["id"];
                    modPropHolder["version"] = bindingEntity["version"];
                    modPropHolder["@@touchedProps"] = bindingEntity["@@touchedProps"].names;

                    bindingEntity.traverseProperties(function (propertyName) {
                        var value = bindingEntity.get(propertyName);
                        var originalValue = _originalBindingEntity.get(propertyName);
                        var valId = bindingEntity['@' + propertyName + '_id'];
                        var origValId = _originalBindingEntity['@' + propertyName + '_id'];
                        
                        // VERY IMPORTANT: the property is considered to be 'modified'
                        //                 in the case when its value does not equal to original value.
                        // 
                        //                 The "modified" property is marked by existence of "val" sub-property.
                        //
                        //                 All modified properties will be applied on the server upon the validation prototype.
                        if (!self._reflector().equalsEx(value, originalValue)) {
                            // the property is 'modified'
                            modPropHolder[propertyName] = {
                                "val": value,
                                "origVal": originalValue
                            };
                            if (propertyName !== 'surrogateVersion') { // need to skip collectional editor surrogate property not to affect @modified
                                modPropHolder["@modified"] = true;
                            }
                            if (typeof valId !== 'undefined') {
                                modPropHolder[propertyName]['valId'] = valId;
                            }
                        } else {
                            // the property is 'unmodified'
                            modPropHolder[propertyName] = {
                                "origVal": originalValue
                            };
                        }
                        if (typeof origValId !== 'undefined') {
                            modPropHolder[propertyName]['origValId'] = origValId;
                        }
                    });
                }
                console.log("       _extractModifiedPropertiesHolder: modPropHolder", modPropHolder);
                return modPropHolder;
            },

            _idConvert: function (id) {
                return id === null ? "new" : ("" + id);
            },
            
            /**
             * Returns 'true' if the entity has been modified from original, 'false' otherwise.
             *
             * @param modifiedPropertiesHolder -- the entity with modified properties
             */
            _hasModified: function (modifiedPropertiesHolder) {
                return modifiedPropertiesHolder["@modified"];
            },

            //////////////////////////////////////// BINDING & UTILS ////////////////////////////////////////
            /**
             * Implements the default action to (re)bind freshly received entity. Entity receival is the result of actions Refresh, Validate, Save and Run.
             *
             * @param isRefreshingProcess -- value true indicates that the call happens as part of refresh lifecycle, which requires resetting the state.
             *                               In all other cases (validate, save, run) value false should be provided.
             */
            _postEntityReceived: function (entity, isRefreshingProcess) {
                var self = this;
                // in case entity is being retrieved need to reset the state, so that the master would behave as if it was created for the first time
                if (isRefreshingProcess) {
                    self._resetState();
                }
                // After the entity has received, potentially its id has been updated:
                if (self._idConvert(entity.id) !== self.entityId) {
                    self.entityId = self._idConvert(entity.id);
                }
                // extract previous version of modified properties holder, to merge it with new version of validated entity for invalida properties!
                var previousModifiedPropertiesHolder = null;
                if (self._currBindingEntity !== null) {
                    previousModifiedPropertiesHolder = self._extractModifiedPropertiesHolder(self._currBindingEntity, self._originalBindingEntity);
                	self._reset(previousModifiedPropertiesHolder);
                }
                const previousEntity = self._currEntity;
                // Determine whether the entity is stale in sense of stale property conflicts (errors).
                const isEntityStale = self._hasStaleConflicts(entity);
                if (isEntityStale) {
                    // version of entity should be taken from previous entity to correctly restore stale entity at the client-side
                    entity.version = self._extractPreviousEntityVersion(previousEntity, entity.version, self._originalBindingEntity);
                }
                // New entity should be promoted to the local cache:
                self._currEntity = entity;
                // before the next assignment -- the editors should be already prepared for "refresh cycle" (for Retrieve and Save actions)
                var oldCurrBindingEntity = self._currBindingEntity;
                self._previousModifiedPropertiesHolder = previousModifiedPropertiesHolder;
                self._currBindingEntity = self._extractBindingView(self._currEntity, previousModifiedPropertiesHolder, self._currBindingEntity);
                if (self._currBindingEntity != null && oldCurrBindingEntity == null) {
                    self.fire('binding-entity-appeared', self._currBindingEntity);
                }
                self._originalBindingEntity = self._extractOriginalBindingView(self._currEntity, isEntityStale ? self._originalBindingEntity : null);
                
                self._bindingEntityModified = self._hasModified(self._extractModifiedPropertiesHolder(self._currBindingEntity, self._originalBindingEntity));
                // console.debug('_bindingEntityModified = ', self._bindingEntityModified, ' type = ', self._currBindingEntity.type()._simpleClassName());
                self._bindingEntityNotPersistentOrNotPersistedOrModified = !self._currBindingEntity.type().isPersistent() || 
                                                                           !self._currBindingEntity.isPersisted()         ||
                                                                           self._bindingEntityModified;
                // console.debug('_bindingEntityNotPersistentOrNotPersistedOrModified = ', self._bindingEntityNotPersistentOrNotPersistedOrModified, ' type = ', self._currBindingEntity.type()._simpleClassName());

                console.log("       _postEntityReceived: _currBindingEntity + _originalBindingEntity", self._currBindingEntity, self._originalBindingEntity);
                return self._currBindingEntity;
            },
            
            /**
             * Returns 'true' in case where the entity has at least one stale conflict, 'false' otherwise.
             *
             * Please, note that in sense of versions the entity could be stale, but this method still returns 'false' if no stale conflicts exist,
             * and thus the entity will be treated as NOT 'stale'.
             * That means that fully resolvable staleness will not be appearing to the user -- this is the case where behind the scenes 
             * the entity has been saved one or more times (by other user) but saving did not actually change the entity to the level of conflicts appearance.
             * However, warnings 'The property has been recently changed by another user.' could exist in this case.
             */
            _hasStaleConflicts: function (entity) {
                const self = this;
                var hasStaleConflicts = false;
                entity.traverseProperties(function (propertyName) {
                    const validationResult = entity.prop(propertyName).validationResult();
                    if (self._reflector().isError(validationResult) && (validationResult['@resultType'] === 'ua.com.fielden.platform.web.utils.PropertyConflict')) {
                        hasStaleConflicts = true;
                    }
                });
                return hasStaleConflicts;
            },
            
            /**
             * Extracts the version of previous entity for the case where new entity is stale.
             *
             * This method validates existence of previous entity / originalBindingEntity and the fact that the version has been increased.
             * These validations are required because new entity should not be stale otherwise.
             */
            _extractPreviousEntityVersion: function (previousEntity, currentEntityVersion, _originalBindingEntity) {
                if (previousEntity == null) {
                    throw 'Previous version of entity does not exist, but somehow the stale entity has arrived from the server.';
                }
                if (currentEntityVersion <= previousEntity.version) {
                    throw 'Previous version of entity has [' + previousEntity.version + '] version, that is not lower than the version of stale new entity (' + currentEntityVersion + ').';
                }
                if (_originalBindingEntity === null) {
                    throw 'Previous version of _originalBindingEntity does not exist, but somehow the stale entity has arrived from the server.';
                }
                return previousEntity.version;
            },

            /**
             * Creates a binding view of the entity from its fully fledged representation.
             *
             * @param entity -- a fully fledged entity representation
             * @param previousModifiedPropertiesHolder -- a container holding original and current value for all entity properties used to represent invalid properties to the user; 
             *                                            this container is always null for brand new entity instances that arrive from the sever for the first time (i.e. further client-server conversation re new instances should populate this container). 
            */
            _extractBindingView: function (entity, previousModifiedPropertiesHolder, prevCurrBindingEntity) {
                var self = this;
                var bindingView = self._reflector().newEntity(entity.type().fullClassName());
                bindingView["id"] = entity["id"];
                bindingView["version"] = entity["version"];
                // this property of the bindingView will hold the reference to fully-fledged entity, 
                //   this entity can be used effectively to process 'dot-notated' properties (for e.g. retrieving the values) 
                bindingView["@@origin"] = entity;
                bindingView["@@touchedProps"] = (prevCurrBindingEntity && prevCurrBindingEntity["@@touchedProps"]) ? prevCurrBindingEntity["@@touchedProps"] : { names: [], counts: [] };

                entity.traverseProperties(function (propertyName) {
                    // value conversion of property value performs here only for specialised properties (see method '_isNecessaryForConversion');
                    // conversion for other properties performs in corresponding editors (tg-editor-behavior).
                    if (self._isNecessaryForConversion(propertyName)) {
                        self._reflector().convertPropertyValue(bindingView, propertyName, entity, previousModifiedPropertiesHolder);
                    }
                    
                    // meta-state is provided for all properties, not only specialised
                    if (self._reflector().isError(entity.prop(propertyName).validationResult())) {
                        bindingView["@" + propertyName + "_error"] = entity.prop(propertyName).validationResult();
                    } else {
                        if (self._reflector().isWarning(entity.prop(propertyName).validationResult())) {
                            bindingView["@" + propertyName + "_warning"] = entity.prop(propertyName).validationResult();
                        }
                        bindingView["@" + propertyName + "_required"] = entity.prop(propertyName).isRequired();
                    }
                    // the following logic is required in both cases: property with error and without error
                    if (entity.type().prop(propertyName).isUpperCase()) {
                        bindingView["@" + propertyName + "_uppercase"] = true;
                    }
                    bindingView["@" + propertyName + "_editable"] = entity.prop(propertyName).isEditable();
                });

                // console.log("       entity + bindingView", entity, bindingView);
                return bindingView;
            },
            
            /**
             * Defines whether the property should be converted to binding entity representation regardless of existence of corresponding editor.
             */
            _isNecessaryForConversion: function (propertyName) {
                return ['entityType', 'importUri', 'elementName', 'entityId', // entity edit / new standard actions
                        'forNew', 'menuTitle', 'sectionTitle', // compound master opening actions
                        'pageCapacity', // export actions ('mime', 'fileName', 'data' props are not needed because post action success uses fully-fledged version of entity)
                        'surrogateVersion', 'chosenIds', 'addedIds', 'removedIds', 'sortingVals', // collectional modification actions
                        'visibleMenuItems', 'invisibleMenuItems', // menu visibility action (MenuSaveAction)
                        'skipUi' // specialised property to control functional entity master appearance
                       ].indexOf(propertyName) !== -1;
            },
            
            /**
             * Extracts binding view from 'entity' for its original values taking into account that entity could be 'stale'.
             *
             * In case of stale entity (previousEntity has been passed into this method), original values should be taken from the previous version of the entity to be able to mimic restoration of stale instance.
             */
            _extractOriginalBindingView: function (entity, previousOriginalBindingEntity) {
                var stale = previousOriginalBindingEntity !== null;
                var self = this;
                var originalBindingView = self._reflector().newEntityEmpty();

                originalBindingView["_type"] = entity["_type"];
                originalBindingView["id"] = entity["id"];
                originalBindingView["version"] = entity["version"];
                // this property of the bindingView will hold the reference to fully-fledged entity, 
                //   this entity can be used effectively to process 'dot-notated' properties (for e.g. retrieving the values) 
                originalBindingView["@@origin"] = (stale === true ? previousOriginalBindingEntity['@@origin'] : entity);

                entity.traverseProperties(function (propertyName) {
                    // value conversion of original property value performs here only for specialised properties (see method '_isNecessaryForConversion');
                    // conversion for other properties performs in corresponding editors (tg-editor-behavior).
                    if (self._isNecessaryForConversion(propertyName)) {
                        self._reflector().convertOriginalPropertyValue(originalBindingView, propertyName, originalBindingView["@@origin"]);
                    }
                });

                // console.log("       entity + originalBindingView", entity, bindingView);
                return originalBindingView;
            },
            
            /** 
             * This uuid property observer has only an assistive role at this stage -- to track uuid changes if needed.
             * However, it has a potential to be used for subscribing to various message topics associated with a channel that has the same value as uuid.
             * In this case changes to uuid should handle unsubscribing to previously subscribed channels (i.e. oldValue). 
             */
            _uuidChanged: function (newValue, oldValue) {
            	if (oldValue !== undefined) {
            		console.warn('Property uuid for element <', this.is, '> has changed from "', oldValue, '" to "', newValue, '".');
            	}
            },
            
            /**
             * Sets the value of entity property ('propNameFromFuncEntityToAssign') to the property editor with propertyName 'propNameToBeAssigned'.
             */
            setEditorValue4Property: function (propNameToBeAssigned, entity, propNameFromFuncEntityToAssign) {
            	var editor = this.$.masterDom.querySelector('[id=editor_4_' + propNameToBeAssigned + ']');
                editor.assignValue(entity, propNameFromFuncEntityToAssign, editor.reflector().getPropertyValue.bind(editor.reflector()));
                editor.commit();
            },
            
            /**
             * Sets the value of entity property ('propNameFromFuncEntityToAssign') to the property editor with propertyName 'propNameToBeAssigned'.
             */
            setEditorValue4PropertyFromConcreteValue: function (propNameToBeAssigned, value) {
            	var editor = this.$.masterDom.querySelector('[id=editor_4_' + propNameToBeAssigned + ']');
                editor.assignConcreteValue(value, editor.reflector().convert.bind(editor.reflector()));
                editor.commit();
            },
            
            disableView: function () {
                this._disablementCounter += 1;
                if (this._disablementCounter > 0 && this.currentState !== 'VIEW') { 
                    this.disableViewForDescendants();
                }
            },
            disableViewForDescendants: function () {
                this.currentState = 'VIEW';
                if (this.$.loader && this.$.loader.loadedElement) {
                    this.$.loader.loadedElement.disableView();
                }
            },
            enableView: function () {
                if (this._disablementCounter > 0) {
                    this._disablementCounter -= 1;
                    if (this._disablementCounter === 0 && this.currentState !== 'EDIT') {
                        this.enableViewForDescendants();
                    }
                }
            },
            enableViewForDescendants: function () {
                this.currentState = 'EDIT';
                if (this.$.loader && this.$.loader.loadedElement) {
                    this.$.loader.loadedElement.enableView();
                }
            }
        };
    })();
</script>