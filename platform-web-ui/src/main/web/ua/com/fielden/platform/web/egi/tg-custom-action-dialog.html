<link rel="import" href="/app/tg-element-loader.html">
<link rel="import" href="/app/tg-app-config.html">
<link rel="import" href="/resources/polymer/polymer/polymer.html">
<link rel="import" href="/resources/polymer/iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="/resources/polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="/resources/polymer/iron-icon/iron-icon.html">
<link rel="import" href="/resources/polymer/iron-icons/iron-icons.html">
<link rel="import" href="/resources/polymer/iron-icons/av-icons.html">
<link rel="import" href="/resources/polymer/paper-styles/color.html">
<link rel="import" href="/resources/polymer/paper-spinner/paper-spinner.html">
<link rel="import" href="/resources/polymer/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/resources/components/postal-lib.html">
<link rel="import" href="/resources/components/tg-toast.html">
<link rel="import" href="/resources/images/tg-icons.html">
<link rel="import" href="/resources/polymer/paper-styles/paper-styles-classes.html">
<link rel="import" href="/resources/actions/tg-focus-restoration-behavior.html">
<link rel="import" href="/resources/components/tg-tooltip-behavior.html">
<link rel="import" href="/resources/views/tg-back-button-behavior.html">
<link rel="import" href="/resources/reflection/tg-polymer-utils.html">

<dom-module id="tg-custom-action-dialog">
    <template>
        <style>
            :host {
                display: block;
                background: white;
                color: black;
                padding: 0px;
                overflow: auto;
                /* this is to make host scorable when needed */
                box-shadow: rgba(0, 0, 0, 0.24) -2.3408942051048403px 5.524510324047423px 12.090680100755666px 0px, rgba(0, 0, 0, 0.12) 0px 0px 12px 0px;
                @apply(--layout-vertical);
            }
            .title-bar {
                padding: 0 16px 0 8px;
                height: 44px;
                min-height: 44px;
                font-size: 18px;
                cursor: default;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                background-color: var(--paper-light-blue-600);
            }
            #dialogLoader {
                transition: opacity 500ms;
            }
            #loadingPanel {
                visibility: hidden;
                background-color: white;
                font-size: 18px;
                color: var(--paper-grey-400);
            }
            .truncate {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .title-text {
                pointer-events: none;
                overflow: hidden;
            }
            .static-title {
                color: white;
            }
            .dynamic-title {
                color: white;
            }
            .vertical-splitter {
                border-left: 1px solid white;
                height: 1.5em;
                margin: 0 5px
            }
            #menuToggler,#backButton {
                color: white;
            }
            .title-bar-button {
                --paper-icon-button: {
                    color: var(--paper-grey-100);
                };
                --paper-icon-button-disabled: {
                    color: var(--paper-grey-300);
                };
                --paper-icon-button-hover: {
                    color: var(--paper-grey-300);
                };
            }
            .close-button, .navigation-button{
                width: 22px;
                height: 22px;
                padding: 0px;
            }
            .navigation-button{
                margin: 0 8px;
            }
            .minimise-button,.maximise-button {
                width: 19px;
                height: 19px;
                padding: 0px;
                margin-bottom: 2px;
            }
            #navigationBar {
                position: relative;
                color: white;
            }
            #resizer {
                position: absolute;
                bottom: 0;
                right: 0;
                --iron-icon-fill-color: var(--paper-grey-600);
            }
            #resizer:hover {
                cursor: nwse-resize;
            }
            .reverse {
                flex-direction: row-reverse;
            }
            paper-icon-button.button-reverse {
                --paper-icon-button: {
                    transform: scale(-1, 1);
                };
            }
            paper-spinner {
	        	position: absolute;
	            width: 20px;
	            height: 20px; 
	            min-width: 20px; 
	            min-height: 20px; 
	            max-width: 20px; 
	            max-height: 20px; 
	            padding: 0;
	            margin-left: 0;
	            --paper-spinner-layer-1-color: white;
	            --paper-spinner-layer-2-color: white;
	            --paper-spinner-layer-3-color: white;
	            --paper-spinner-layer-4-color: white;
	        }
        </style>
        <div id="titleBar" class="title-bar layout horizontal justified center" on-track="_moveDialog">
            <paper-icon-button id="menuToggler" hidden icon="menu" tooltip-text="Menu" on-tap="_toggleMenu"></paper-icon-button>
            <div class="title-text layout horizontal center flex">
                <span class="static-title truncate">[[staticTitle]]</span>
                <span class="vertical-splitter self-stretch" hidden$="[[_isTitleSplitterHidden(staticTitle, dynamicTitle)]]"></span>
                <span class="dynamic-title truncate" hidden$="[[!dynamicTitle]]">[[dynamicTitle]]</span>
            </div>
            <div id="navigationBar" hidden="[[!_isNavigationBarVisible(_lastAction, _minimised)]]" style$="[[_calcNavigationBarStyle(mobile)]]" class="layout horizontal center">
                <paper-icon-button id="firstEntity" class="button-reverse title-bar-button navigation-button" icon="hardware:keyboard-tab" on-tap="_firstEntry" disabled$="[[!_isNavigatonButtonEnable(_hasPrev, isNavigationActionInProgress)]]" tooltip-text$="[[_getFirstEntryActionTooltip(_lastAction.navigationType)]]"></paper-icon-button>
                <paper-icon-button id="prevEntity" class="title-bar-button navigation-button" icon="hardware:keyboard-backspace" on-tap="_previousEntry" disabled$="[[!_isNavigatonButtonEnable(_hasPrev, isNavigationActionInProgress)]]" tooltip-text$="[[_getPreviousEntryActionTooltip(_lastAction.navigationType)]]"></paper-icon-button>
                <span>[[_sequentialEditText]]</span>
                <paper-icon-button id="nextEntity" class="button-reverse title-bar-button navigation-button" icon="hardware:keyboard-backspace" on-tap="_nextEntry" disabled$="[[!_isNavigatonButtonEnable(_hasNext, isNavigationActionInProgress)]]" tooltip-text$="[[_getNextEntryActionTooltip(_lastAction.navigationType)]]"></paper-icon-button>
                <paper-icon-button id="lastEntity" class="title-bar-button navigation-button" icon="hardware:keyboard-tab" on-tap="_lastEntry" disabled$="[[!_isNavigatonButtonEnable(_hasNext, isNavigationActionInProgress)]]" tooltip-text$="[[_getLastEntryActionTooltip(_lastAction.navigationType)]]"></paper-icon-button>
                <paper-spinner id="spinner" active="[[isNavigationActionInProgress]]" style="display: none;" alt="in progress"></paper-spinner>
            </div>
            <div class="layout horizontal center">
                <!-- collapse/expand buttons -->
                <paper-icon-button hidden="[[!_minimised]]" class="minimise-button title-bar-button" icon="tg-icons:expandMin" on-tap="_invertMinimiseState" tooltip-text="Restore, Alt+c"></paper-icon-button>
                <paper-icon-button hidden="[[_collapserHidden(_minimised, mobile)]]" class="title-bar-button minimise-button" icon="tg-icons:collapseMin"   on-tap="_invertMinimiseState" tooltip-text="Collapse, Alt+c" disabled=[[_dialogInteractionsDisabled(_minimised,_maximised)]]></paper-icon-button>

                <!-- maximize/restore buttons -->
                <paper-icon-button hidden="[[_maximised]]" class="maximise-button title-bar-button" icon="icons:fullscreen"       on-tap="_invertMaximiseState" tooltip-text="Maximise, Alt+m" disabled=[[_dialogInteractionsDisabled(_minimised,_maximised)]]></paper-icon-button>
                <paper-icon-button hidden="[[_maximiseRestorerHidden(_maximised, mobile)]]" class="maximise-button title-bar-button" icon="icons:fullscreen-exit"  on-tap="_invertMaximiseState" tooltip-text="Restore, Alt+m"></paper-icon-button>

                <!-- close/next buttons -->
                <paper-icon-button hidden="[[_closerHidden(_lastAction, mobile)]]" class="close-button title-bar-button" icon="icons:cancel"  on-tap="closeDialog" tooltip-text="Close, Alt+x"></paper-icon-button>
                <paper-icon-button hidden="[[!_lastAction.continuous]]" class="close-button title-bar-button" icon="av:skip-next" on-tap="_skipNext" tooltip-text="Skip to next without saving"></paper-icon-button>
            </div>
        </div>
        <div id="dialogBody" class="relative flex layout vertical">
            <div id="loadingPanel" class=" fit layout horizontal center-center">Loading master...</div>
            <div id="dialogLoader" class="flex layout horizontal">
                <tg-element-loader id="elementLoader"></tg-element-loader>
            </div>
        </div>
        <iron-icon id="resizer" hidden=[[_dialogInteractionsDisabled(_minimised,_maximised)]] icon="tg-icons:resize-bottom-right" on-track="resizeDialog" tooltip-text="Drag to resize"></iron-icon>
        <tg-toast id="toaster"></tg-toast>
        <tg-app-config id="appConfig" mobile="{{mobile}}"></tg-app-config>
    </template>
</dom-module>
<script>
    (function() {
        const findParentDialog = function(action) {
            let parent = action;
            while (parent && parent.tagName !== 'TG-CUSTOM-ACTION-DIALOG') {
                parent = parent.parentElement;
            }
            return parent;
        }
        Polymer({

            is: "tg-custom-action-dialog",

            behaviors: [
                Polymer.IronA11yKeysBehavior,
                Polymer.IronOverlayBehavior,
                Polymer.TgBehaviors.TgFocusRestorationBehavior,
                Polymer.TgBehaviors.TgTooltipBehavior,
                Polymer.TgBehaviors.TgBackButtonBehavior
            ],

            listeners: {
                'iron-overlay-opened': '_dialogOpened',
                'iron-overlay-closed': '_dialogClosed',
                'tg-dynamic-title-changed': '_updateDynamicTitle',
                'tg-menu-appeared': '_updateMenuButton',
                'tg-master-type-changed': '_handleMasterChanged',
                'tg-master-type-before-change': '_handleMasterBeforeChange'
            },

            hostAttributes: {
                'tabindex': '0'
            },

            properties: {
                isRunning: {
                    type: Boolean,
                    readOnly: true
                },

                /**
                 * Title bar properties firs of them is static title and the other one is dynamic it can changed when user interacts with dialog.
                 */
                staticTitle: {
                    type: String,
                    value: ""
                },
                dynamicTitle: {
                    type: String,
                    value: ""
                },
                prefDim: {
                    type: Object
                },
                
                ///////The properties needed for synchronising animation steps during master changes.///
                _masterVisibilityChanges: {
                    type: Boolean
                },
                
                _masterLayoutChanges: {
                    type: Boolean
                },
                /////////////////////////////////////////////////////////////////////////////////////////

                /**
                 * Indicates whether dialog was moved using title bar dragging. This will be reset after dialog closes.
                 */
                _wasMoved: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Indicates whether dialog was resized using bottom right corner's resizer. This will be reset after dialog closes.
                 */
                _wasResized: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Indicates whether dialog has been collapsed using 'Collapse' button.
                 */
                _minimised: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Indicates whether dialog has been maximised using 'Maximise' button.
                 */
                _maximised: {
                    type: Boolean,
                    value: false
                },

                /* Postal subscription to events that trigger dialog closing.
                 * It gets populated in _showDialog and unsubscrived on dialog closed.
                 */
                _subscriptions: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },

                /**
                 * An object that caches already loaded, created and already represented by this dialog elements.
                 * It is used as an optimisation technique to prevent repeated instantiation of elements.
                 * Properties represent element names and their values -- element instances.
                 */
                _cachedElements: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },

                /** Captures the last action that has been executed by this dialog or is currently in progress. */
                _lastAction: {
                    type: Object
                },

                /** A master element that corresponds to the _lastAction. */
                _lastElement: {
                    type: Object
                },
                
                /** Navigation related properties*/
                _hasPrev: {
                    type: Boolean,
                    value:true
                },
                
                _hasNext: {
                    type: Boolean,
                    value:true
                },
                
                _sequentialEditText: {
                    type: String,
                    value: ''
                },
                //////////////////////////////////

                /**The parent dialog tow wchich this dialog is a child.*/
                _parentDialog: {
                    type: Object
                },

                /**List of child dialogs*/
                _childDialogs: {
                    type: Array
                },

                /**
                 * Needed to prevent user from dragging dialog out of the window rectangle. Caches window width and height.
                 */
                _windowWidth: Number,
                _windowHeight: Number,

                /**
                 * Binds to the property 'appConfig.mobile'.
                 */
                mobile: {
                    type: Boolean
                }
            },

            observers: ["_updateDialogDimensions(prefDim, _minimised, _maximised)", "_updateDialogAnimation(_masterVisibilityChanges, _masterLayoutChanges)"],

            keyBindings: {
                'alt+c': '_invertMinimiseState',
                'alt+m': '_invertMaximiseState',
                'alt+x': 'closeDialog',
                'ctrl+up': '_firstEntry',
                'ctrl+left': '_previousEntry',
                'ctrl+right': '_nextEntry',
                'ctrl+down': '_lastEntry'
            },

            ready: function() {
                this.noAutoFocus = true;
                this.noCancelOnOutsideClick = true;
                this.noCancelOnEscKey = true;

                this._parentDialog = null;
                this._childDialogs = [];

                // Listen to mousedown or touchstart to be sure to be the first to capture
                // clicks outside the overlay.
                this._onCaptureClick = this._onCaptureClick.bind(this);
                this._onCaptureFocus = this._onCaptureFocus.bind(this);
                this._onCaptureKeyDown = this._onCaptureKeyDown.bind(this);

                this._focusDialogWithInput = this._focusDialogWithInput.bind(this);
                this._fitWhenFirstTimeOpened = this._fitWhenFirstTimeOpened.bind(this);
                this._finishErroneousOpening = this._finishErroneousOpening.bind(this);
                this._handleActionNavigationChange = this._handleActionNavigationChange.bind(this);

                this._setIsRunning(false);

                if (this.mobile === true && this.$.appConfig.iPhoneOs()) {
                    Polymer.dom(this.$.titleBar).appendChild(this.createBackButton());
                    Polymer.dom.flush();
                    this.$.titleBar.classList.add('reverse');
                }
                //Add listener for custom event that was thrown when dialogs view is about to lost focus, then this focus should go to title-bar.
                this.addEventListener("tg-last-item-focused", this._viewFocusLostEventListener.bind(this));
                //Retrieve title's bar element to focus.
                this._componentsToFocus = Array.from(this.$.titleBar.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
                //Add event listener that listens when dialog body chang it's opacity
                this.$.dialogLoader.addEventListener("transitionend", this._handleBodyTransitionEnd.bind(this));
            },

            attached: function() {
                var clickEvent = ('ontouchstart' in window) ? 'touchstart' : 'mousedown';
                this.addEventListener(clickEvent, this._onCaptureClick, true);
                this.addEventListener('focus', this._onCaptureFocus, true);
                this.addEventListener('keydown', this._onCaptureKeyDown, true);
            },

            detached: function() {
                var clickEvent = ('ontouchstart' in window) ? 'touchstart' : 'mousedown';
                this.removeEventListener(clickEvent, this._onCaptureClick, true);
                this.removeEventListener('focus', this._onCaptureFocus, true);
                this.removeEventListener('keydown', this._onCaptureKeyDown, true);
            },

            _getCurrentFocusableElements: function() {
                return this._componentsToFocus.filter(element => !element.disabled && element.offsetParent !== null);
            },

            _onTabDown: function(e) {
                this._focusChange(e, true);
            },

            _onShiftTabDown: function(e) {
                this._focusChange(e, false);
            },

            _focusChange: function(e, forward) {
                const focusables = this._getCurrentFocusableElements();
                const lastIndex = forward ? focusables.length - 1 : 0;
                const firstIndex = forward ? 0 : focusables.length - 1;
                const callback = this._lastElement ? (forward ? this._lastElement.focusNextView.bind(this._lastElement) : this._lastElement.focusPreviousView.bind(this._lastElement)) : null;
                if (document.activeElement === this || isInHierarchy(this.$.titleBar, document.activeElement)) {
                    if (document.activeElement === focusables[lastIndex]) {
                        if (callback) {
                            callback(e);
                        } else {
                            focusables[firstIndex].focus();
                            tearDownEvent(e);
                        }
                    }
                } else if (callback) {
                    callback(e);
                }
            },

            _viewFocusLostEventListener: function(e) {
                const focusables = this._getCurrentFocusableElements();
                const callback = this._lastElement ? (e.detail.forward ? this._lastElement.focusNextView : this._lastElement.focusPreviousView) : null;
                if (focusables.length > 0) {
                    if (e.detail.forward) {
                        focusables[0].focus();
                    } else {
                        focusables[focusables.length - 1].focus();
                    }
                    tearDownEvent(e.detail.event);
                } else if (callback) {
                    callback(e.detail.event);
                }
                tearDownEvent(e);

            },

            _onCaptureClick: function(event) {
                if (this._manager.currentOverlay() !== this) {
                    console.log("select overlay");
                    this._bringToFront();
                }
            },

            _onCaptureFocus: function(event) {
                if (this._manager.currentOverlay() !== this) {
                    console.log("select overlay");
                    this._bringToFront();
                }
            },

            _onCaptureKeyDown: function(event) {
                if (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {
                    if (event.shiftKey) {
                        this._onShiftTabDown(event);
                    } else {
                        this._onTabDown(event);
                    }
                    if (this._manager.currentOverlay() !== this) {
                        console.log("select overlay");
                        this._bringToFront();
                    }
                }
            },

            _bringToFront: function() {
                this._manager.addOverlay(this);
                this._childDialogs.forEach(function(childDialog) {
                    childDialog._bringToFront();
                });
            },

            _skipNext: function() {
                if (this._lastAction && this._lastAction.continuous && typeof this._lastAction.skipNext === 'function') {
                    // skipping to next is an explicit action that disregards any unsaved changes
                    this.closeDialog(true);
                    if (!this.opened) {
                        this._lastAction.skipNext();
                    }
                }
            },
            
            //////////////////////////////////entity master navigation related//////////////////////////////
            _isNavigationBarVisible: function (lastAction, minimised) {
                return lastAction && lastAction.supportsNavigation && !minimised;
            },
            
            _calcNavigationBarStyle: function (mobile) {
                if (mobile) {
                    if (this.$.appConfig.iPhoneOs()) {
                        return "margin-right: 10px;"
                    }
                    return "margin-left:10px;"
                } else {
                    return "margin:0 20px;" 
                }
            },
            
            _isNavigatonButtonEnable: function (hasNextEntry, isNavigationActionInProgress) {
                return hasNextEntry && !isNavigationActionInProgress;
            },
            
            _firstEntry: function () {
                if (this.canClose() && this._hasPrev) {
                    this._displaySpinnerOn(this.$.firstEntity);
                    this._lastAction.firstEntry();
                }
            },
            
            _previousEntry: function () {
                if (this.canClose() && this._hasPrev) {
                    this._displaySpinnerOn(this.$.prevEntity);
                    this._lastAction.previousEntry();
                }
            },
            
            _nextEntry: function () {
                if (this.canClose() && this._hasNext) {
                    this._displaySpinnerOn(this.$.nextEntity);
                    this._lastAction.nextEntry();
                }
            },
            
            _lastEntry: function () {
                if (this.canClose() && this._hasNext) {
                    this._displaySpinnerOn(this.$.lastEntity);
                    this._lastAction.lastEntry();
                }
            },
            
            _displaySpinnerOn: function (element) {
                this.$.spinner.style.removeProperty("display");
                this.$.spinner.style.left = element.offsetLeft + (element.offsetWidth / 2 - this.$.spinner.offsetWidth / 2) + 'px';
                this.$.spinner.style.top = element.offsetTop + (element.offsetHeight / 2 - this.$.spinner.offsetHeight / 2) + 'px';
                this.isNavigationActionInProgress = true;
            },
            
            _getFirstEntryActionTooltip: function (_navigationType) {
                return "Get first " + _navigationType;
            },
            
            _getPreviousEntryActionTooltip: function (_navigationType) {
                return "Get previous " + _navigationType;
            },
            
            _getNextEntryActionTooltip: function (_navigationType) {
                return "Get next " + _navigationType;
            },
            
            _getLastEntryActionTooltip: function (_navigationType) {
                return "Get last " + _navigationType;
            },
            ////////////////////////////////////////////////////////////////////////////////////////////////

            _invertDialogState: function(stateName) {
                if (!this[stateName]) {
                    this.persistActiveElement();
                    this.focus();
                    this.persistDialogLocationAndDimensions();
                }
                this[stateName] = !this[stateName];
                this.notifyResize(); // notify children about resize of action dialog (for e.g. to re-draw shadow of tg-entity-master's actionContainer)
                if (!this[stateName]) {
                    this.restoreActiveElement();
                    this.restoreDialogLocationAndDimensions();
                    this.notifyResize(); // notify children about resize of action dialog (for e.g. to re-draw shadow of tg-entity-master's actionContainer)
                }
            },

            _invertMinimiseState: function() {
                if (!this._maximised) { // need to skip the action if dialog is in maximised state: this is needed for alt+m collapsing
                    this._invertDialogState('_minimised');
                }
            },

            _invertMaximiseState: function() {
                if (!this.prefDim) { // define prefDim (maximise action) if it was not defined using action configuration
                    this.prefDim = this._lastElement.makeResizable();
                }
                this._invertDialogState('_maximised');
            },

            /**
             * Dialog resizing handler assigned to resizing button in bottom right corner of the dialog.
             */
            resizeDialog: function(event) {
                const target = event.target || event.srcElement;
                if (target === this.$.resizer) {
                    switch (event.detail.state) {
                        case 'start':
                            document.styleSheets[0].insertRule('* { cursor: nwse-resize !important; }', 0); // override custom cursors in all application with resizing cursor
                            break;
                        case 'track':
                            if (!this._wasResized) {
                                this._wasResized = true;
                                this.heightBeforeResizing = this.style.height;
                                this.widthBeforeResizing = this.style.width;
                                if (!this.prefDim) { // define prefDim (resize action) if it was not defined using action configuration
                                    this.prefDim = this._lastElement.makeResizable();
                                }
                            }
                            const resizedHeight = this.offsetHeight + event.detail.ddy;
                            const heightNeedsResize = resizedHeight >= 44 /* toolbar height*/ + 14 /* resizer image height */ ;
                            if (heightNeedsResize) {
                                this.style.height = resizedHeight + 'px';
                            }
                            const resizedWidth = this.offsetWidth + event.detail.ddx;
                            const widthNeedsResize = resizedWidth >= 60 /* reasonable minimum width of text */ + (16 * 2) /* padding left+right */ + (22 * 3) /* three buttons width */
                            if (widthNeedsResize) {
                                this.style.width = resizedWidth + 'px';
                            }
                            if (heightNeedsResize || widthNeedsResize) {
                                this.notifyResize();
                            }
                            break;
                        case 'end':
                            document.styleSheets[0].deleteRule(0);
                            break;
                    }
                }
                if (event.stopPropagation) event.stopPropagation();
                if (event.preventDefault) event.preventDefault();
                event.cancelBubble = true;
                event.returnValue = false;
            },

            /**
             * Persists current dialog location (top, left) and dimensions (height, width) to be restored later.
             */
            persistDialogLocationAndDimensions: function() {
                this.persistedTop = this.style.top;
                this.persistedLeft = this.style.left;
                this.persistedHeight = this.style.height;
                this.persistedWidth = this.style.width;
            },

            /**
             * Restores previously persisted dialog location (top, left) and dimensions (height, width).
             */
            restoreDialogLocationAndDimensions: function() {
                this.style.top = this.persistedTop;
                this.style.left = this.persistedLeft;
                this.style.height = this.persistedHeight;
                this.style.width = this.persistedWidth;
            },

            closeDialog: function(forceClosing) {
                if (forceClosing === true) {
                    this._closeChildren(true);
                    this._closeDialogAndIndicateActionCompletion();
                } else {
                    //Try to close children first.
                    let canClose = this.canClose();
                    if (canClose === true) {
                        this._closeDialogAndIndicateActionCompletion();
                    }
                }
            },
            
            canClose: function () {
                let canClose = this._closeChildren();
                if (canClose && this._lastElement.classList.contains('canLeave')) {
                    const reason = this._lastElement.canLeave();
                    if (reason) {
                        canClose = false;
                        // the reason from .canLeave is not used as it is not always appropriate in the context of dialog closing
                        // for example, when closing a master for a functional entity, the reason states the need to save changes,
                        // while it is also possible and safe to simple cancel them
                        // so, the message below is a good compromise
                        // however, the reason can still insist by providing an imperative hint
                        if (reason.imperative === true) {
                            this.$.toaster.text = reason.msg;
                        } else {
                            this.$.toaster.text = "Please save or cancel changes.";
                        }
                        this.$.toaster.hasMore = false;
                        this.$.toaster.msgText = "";
                        this.$.toaster.showProgress = false;
                        this.$.toaster.isCritical = false;
                        this.$.toaster.show();
                    }
                }
                return canClose;
            },

            _closeChildren: function(forceClosing) {
                var canClose = true;

                this._childDialogs.slice().forEach(function(dialog) {
                    dialog.closeDialog(forceClosing);
                    if (dialog.opened) {
                        canClose = false;
                        if (dialog._minimised) {
                            dialog._invertDialogState('_minimised');
                        }
                        if (!dialog._maximised) {
                            dialog.center();
                        }
                        if (dialog._childDialogs.length === 0) {
                            dialog._focusDialogWithInput();
                        }
                    }
                });
                return canClose;
            },
            
            /**
             * Updates dimensions and position of the dialog based on minimised / maximised state and prefDim appearance.
             */
            _updateDialogDimensions: function(prefDim, minimised, maximised) {
                if (!this._masterVisibilityChanges && !this._masterLayoutChanges) {
                    if (!minimised && !maximised && prefDim) {
                        const width = (typeof prefDim.width === 'function' ? prefDim.width() : prefDim.width) + prefDim.widthUnit;
                        const height = (typeof prefDim.height === 'function' ? prefDim.height() : prefDim.height) + prefDim.heightUnit;
                        this.style.width = width;
                        this.style.height = prefDim.heightUnit === '%' ? height : ('calc(' + height + ' + 44px)'); // +44px - height of the title bar please see styles for .title-bar selector; applicable only for non-relative units of measure
                        this.style.overflow = 'auto';
                    } else if (!minimised && maximised) {
                        this.style.top = this.mobile === true ? '0%' : '2%';
                        this.style.left = this.mobile === true ? '0%' : '2%';
                        this.style.width = this.mobile === true ? '100%' : '96%';
                        this.style.height = this.mobile === true ? '100%' : '96%';
                        this.style.overflow = 'auto';
                    } else if (minimised && !maximised) {
                        this.style.height = '44px';
                        this.style.overflow = 'hidden';
                    } else {
                        this.style.width = '';
                        this.style.height = '';
                        this.style.overflow = 'auto';
                    }
                }
            },

            /**
             * Indicates whether maximising / collapsing / resizing interaction buttons should be disabled (or even hidden) depending on minimised / normal / maximised state of the dialog.
             */
            _dialogInteractionsDisabled: function(minimised, maximised) {
                return minimised || maximised;
            },

            _isTitleSplitterHidden: function(staticTitle, dynamicTitle) {
                return !(staticTitle && dynamicTitle);
            },

            _updateDynamicTitle: function(e) {
                this.dynamicTitle = e.detail;
            },

            /**
             * 'menu-toggler' function to invoke dialog menu. It will be replaced by concrete function from loaded into dialog component in 'updateMenuButton' method.
             */
            _toggleMenu: function() {},

            /**
             * Updates 'hidden' state of the menu toggler button and assigns _toogleMenu function.
             */
            _updateMenuButton: function(event) {
                const appearedAndFunc = event.detail;
                this.$.menuToggler.hidden = !appearedAndFunc.appeared;
                if (appearedAndFunc.appeared) {
                    this._toggleMenu = appearedAndFunc.func;
                    if (this.mobile === true && this.$.appConfig.iPhoneOs()) {
                        appearedAndFunc.drawer.rightDrawer = true;
                    }
                }
            },

            _moveDialog: function(e) {
                var target = e.target || e.srcElement;
                if (target === this.$.titleBar && this._maximised === false) {
                    switch (e.detail.state) {
                        case 'start':
                            this.$.titleBar.style.cursor = 'move';
                            this._windowHeight = window.innerHeight;
                            this._windowWidth = window.innerWidth;
                            break;
                        case 'track':
                            const _titleBarDimensions = this.$.titleBar.getBoundingClientRect();
                            if (_titleBarDimensions.right + e.detail.ddx >= 44 && _titleBarDimensions.left + e.detail.ddx <= this._windowWidth - 44) {
                                this.style.left = parseInt(this.style.left) + e.detail.ddx + 'px';
                                this.persistedLeft = this.style.left;
                                this._wasMoved = true;
                            }
                            if (_titleBarDimensions.top + e.detail.ddy >= 0 && _titleBarDimensions.bottom + e.detail.ddy <= this._windowHeight) {
                                this.style.top = parseInt(this.style.top) + e.detail.ddy + 'px';
                                this.persistedTop = this.style.top;
                                this._wasMoved = true;
                            }
                            break;
                        case 'end':
                            this.$.titleBar.style.removeProperty('cursor');
                            break;
                    }
                }
                if (event.stopPropagation) event.stopPropagation();
                if (event.preventDefault) event.preventDefault();
                event.cancelBubble = true;
                event.returnValue = false;
            },

            _closeDialogAndIndicateActionCompletion: function() {
                if (this._lastAction) {
                    this._lastAction.isActionInProgress = false;
                }
                if (this._minimised) {
                    this.restoreActiveElement();
                }
                if (this._parentDialog) {
                    var childIndex = this._parentDialog._childDialogs.indexOf(this);
                    if (childIndex > -1) {
                        this._parentDialog._childDialogs.splice(childIndex, 1);
                    }
                    this._parentDialog = null;
                }
                this.close();
            },

            _handleCloseEvent: function(data, envelope) {
                if (data.canClose === true || this._lastAction.continuous) {
                    this._closeDialogAndIndicateActionCompletion();
                }
            },

            /** A convenient method that return a Promise that resolves to an element instaces from cache or from the element loader. */
            _getElement: function(customAction) {
                var self = this;
                var key = customAction.elementAlias ? customAction.elementAlias : customAction.elementName;
                // disabled chache (temprarily?) to support polymorphic masters
                 if (self._cachedElements.hasOwnProperty(key)) {
                    console.log("Reusing cached element:", key);
                    var element = self._cachedElements[key];
                    self.$.elementLoader.insert(element);
                    return Promise.resolve(element);
                } else { 
                    self.$.elementLoader.import = customAction.componentUri;
                    self.$.elementLoader.elementName = customAction.elementName;
                    self.$.elementLoader.attrs = customAction.attrs;
                    return self.$.elementLoader.reload();
                }
            },

            /*
             * customAction -- an action that was actioned by user and may require showing a diglog (e.g. with master)
             * closeEventChannel -- a channel that is provided from the outside and is used to publish for listening to event that should leade to closing of this dialog.
             * closeEventTopics -- event topics that should be listened to on the channel to close this dialog.
             */
            showDialog: function(customAction, closeEventChannel, closeEventTopics) {
                if (this.opened === true) {
                    this.$.toaster.text = 'Please close the currently open dialog.';
                    this.$.toaster.hasMore = true;
                    this.$.toaster.msgText = 'Any operation on the currently open dialog should be completed and the dialog closed before opening any other dialog.';
                    this.$.toaster.showProgress = false;
                    this.$.toaster.isCritical = false;
                    this.$.toaster.show();
                    console.log("The dialog is already opened and should be closed be being used again.");
                    if (customAction) {
                        customAction.restoreActiveElement();
                    }
                } else {
                    var self = this;
                    if (self.isRunning === false) {
                        self._lastAction = this._customiseAction(customAction);
                        self._setIsRunning(true);
                        self.staticTitle = customAction.shortDesc;
                        self.dynamicTitle = null;

                        self._getElement(customAction)
                            .then(function(element) {
                                var promise = customAction._onExecuted(null, element, null);
                                if (promise) {
                                    return promise
                                        .then(function(ironRequest) {
                                            var key = customAction.elementAlias ? customAction.elementAlias : customAction.elementName;
                                            if (!self._cachedElements.hasOwnProperty(key)) {
                                                if (typeof element['canBeCached'] === 'undefined' || element.canBeCached() === true) {
                                                    console.log("caching:", key);
                                                    self._cachedElements[key] = element;
                                                }
                                            }
                                            if (ironRequest && typeof ironRequest.successful !== 'undefined' && ironRequest.successful === true) {
                                                return Promise.resolve(self._showMaster(customAction, element, closeEventChannel, closeEventTopics));
                                            } else {
                                                return Promise.reject('Retrieval / saving promise was not successful.');
                                            }
                                        })
                                        .catch(function(error) {
                                            self._finishErroneousOpening();
                                        });
                                } else {
                                    return Promise.resolve()
                                        .then(function() {
                                            return Promise.resolve(self._showMaster(customAction, element, closeEventChannel, closeEventTopics));
                                        })
                                        .catch(function(error) {
                                            self._finishErroneousOpening();
                                        });
                                }
                            })
                            .catch(function(error) {
                                console.error(error);
                                self.$.toaster.text = 'There was an error displaying the dialog.';
                                self.$.toaster.hasMore = true;
                                self.$.toaster.msgText = 'There was an error displaying the dialog.<br><br> \
	                                                      <b>Error cause:</b><br>' + error.message;
                                self.$.toaster.showProgress = false;
                                self.$.toaster.isCritical = true;
                                self.$.toaster.show();
                                if (self._lastAction) {
                                    self._lastAction.restoreActiveElement();
                                }
                            });
                    }
                }
            },
            
            _customiseAction: function (newAction) {
                if (this._lastAction && this._lastAction.supportsNavigation) {
                    this._lastAction.removeEventListener("tg-action-navigation-changed", this._handleActionNavigationChange);
                }
                if (newAction) {
                    this.staticTitle = newAction.shortDesc;
                    if (newAction.supportsNavigation) {
                        newAction.addEventListener("tg-action-navigation-changed", this._handleActionNavigationChange);
                        this._setNavigationDetails(newAction);
                    }
                }
                return newAction;
            },
            
            _handleActionNavigationChange: function (e) {
                this._setNavigationDetails(e.detail);
                this._resetSpinner();
            },
            
            _resetSpinner: function () {
                if (this.isNavigationActionInProgress) {
                    this.isNavigationActionInProgress = false;
                    this.$.spinner.style.display = 'none';
                }
            },
            
            _setNavigationDetails: function (obj) {
                this._hasPrev = obj.hasPrev;
                this._hasNext = obj.hasNext;
                this._sequentialEditText = "" + (obj.count > 0 ? obj.entInd + 1 : 0) + " / " + obj.count;
            },
            
            _updateDialogAnimation: function (_masterVisibilityChanges, _masterLayoutChanges) {
                if (!_masterVisibilityChanges && !_masterLayoutChanges) {
                    if (!this._wasResized) {
                        this._updateDialogDimensions(this.prefDim, this._minimised, this._maximised);
                    }
                    if (!this._wasMoved) {
                        this._updateDialogPosition(this.prefDim, this._minimised, this._maximised);
                    }
                    this.async(this._dialogResized, 500);
                }
            },
            
            _dialogResized: function () {
                this.style.removeProperty("transition-property");
                this.style.removeProperty("transition-duration");
                this._masterVisibilityChanges = true;
                this.$.elementLoader.style.removeProperty("display");
                this.$.dialogLoader.style.opacity = "1";
                
            },
            
            _updateDialogPosition: function (prefDim, _minimised, _maximised) {
                if (!_minimised && !_maximised ) {
                    const width = (typeof prefDim.width === 'function' ? prefDim.width() : prefDim.width) + prefDim.widthUnit;
                    const isWidthPercentage = width.endsWith('%');
                    const widthNum = parseFloat(width);
                    const windowWidth = this._fitWidth;
                    if (!isNaN(widthNum) && !isWidthPercentage && windowWidth < widthNum) {
                        this.style.left = "0px";
                    } else {
                        this.style.left = "calc(" + windowWidth + "px / 2  - " + width + " / 2)";
                    }
                    const height = (typeof prefDim.height === 'function' ? prefDim.height() : prefDim.height) + prefDim.heightUnit;
                    const isHeightPercentage = height.endsWith('%');
                    const heightNum = parseFloat(height);
                    const windowHeight = this._fitHeight;
                    if (!isNaN(heightNum) && !isHeightPercentage && windowHeight < heightNum + 44) {
                        this.style.top = "0px";
                    } else {
                        this.style.top = "calc(" + windowHeight + "px / 2  - " + height + " / 2" + (isHeightPercentage ? ")" : " - 44px / 2)");
                    }
                }
            },
            
            _handleMasterBeforeChange: function () {
                if (this.opened) {
                    //First animate master body hiding
                    this._masterVisibilityChanges = true;
                    this._masterLayoutChanges = true;
                    this.$.loadingPanel.style.visibility = "visible";
                    this.$.dialogLoader.style.opacity = "0";
                    //Then set dimension properties as transitional for dialog for futher animation.
                    this.style.transitionProperty = "top, left, width, height";
                    this.style.transitionDuration = "500ms";
                }
            },
            
            _handleMasterChanged: function (e) {
                if (this.opened) {
                    this._masterLayoutChanges = false;
                }
            },
            
            _handleBodyTransitionEnd: function (e) {
                if (e.target === this.$.dialogLoader) {
                    if (this.$.dialogLoader.style.opacity === "0") {
                        this.$.elementLoader.style.display = "none";
                        this._masterVisibilityChanges = false;
                    } else {
                        this._masterVisibilityChanges = undefined;
                        this._masterLayoutChanges = undefined;
                        this.$.loadingPanel.style.visibility = "hidden";
                        this.notifyResize();
                        this._focusDialogWithInput();
                    }
                    
                }
            },
            
            _showMaster: function(action, element, closeEventChannel, closeEventTopics) {
                this._lastElement = element;
                const self = this;
                if (element.noUI === true) { // is this is the end of action execution?
                    self._setIsRunning(false);
                } else { // otherwise show master in dialog
                    if (element.masterWithMaster || element.masterWithCentre) { // defer opening of master-with-master's / master-with-centre's dialog until binding-entity / egi-entities of embedded master / centre appear
                        const resultsName = element.masterWithMaster ? 'binding-entity' : 'egi-entities';
                        const resultsAppearedEvent = resultsName + '-appeared';
                        const resultsDidNotAppearEvent = resultsName + '-did-not-appear';

                        this.addEventListener(resultsAppearedEvent, this._fitWhenFirstTimeOpened);

                        this._openOnceConcrete = this._openOnce.bind(this, closeEventChannel, closeEventTopics, action, resultsAppearedEvent, resultsDidNotAppearEvent);
                        this.addEventListener(resultsAppearedEvent, this._openOnceConcrete);
                        this._doNotOpenConcrete = this._doNotOpen.bind(this, resultsAppearedEvent, resultsDidNotAppearEvent);
                        this.addEventListener(resultsDidNotAppearEvent, this._doNotOpenConcrete);
                    } else {
                        this.addEventListener('binding-entity-appeared', this._fitWhenFirstTimeOpened);

                        this._openOnce(closeEventChannel, closeEventTopics, action, null, null);
                    }
                }
            },

            refit: function() {
                Polymer.IronFitBehavior.refit.call(this);

                // There is a need to reset max-width and max-height styles after every refit call.
                // This is necessary to make dialog being able to 'maximise' to large dimensions.
                this.style.maxHeight = '100%';
                this.style.maxWidth = '100%';
            },

            /**
             * Starts actual opening of the dialog: adds 'closing' subscriptions, performs refitting and invokes this.open().
             */
            _openOnce: function(closeEventChannel, closeEventTopics, action, resultsAppearedEvent, resultsDidNotAppearEvent) {
                this._clearOpeningListeners(resultsAppearedEvent, resultsDidNotAppearEvent);
                const self = this;
                // if there would be a master UI then need to subscribe for this dialog closing messages
                if (closeEventChannel && closeEventTopics && closeEventTopics.length > 0) {
                    self._subscriptions = [];
                    for (var index = 0; index < closeEventTopics.length; index++) {
                        self._subscriptions.push(
                            postal.subscribe({
                                channel: closeEventChannel,
                                topic: closeEventTopics[index],
                                callback: self._handleCloseEvent.bind(self)
                            }));
                    }
                }
                this.updateStyles();
                this.refit();
                // let's open the dialog with magical async...
                // this ensures that the dialog is opened after its relocation to body and after all layouting is done
                this.async(function() {
                    //Configuring the dialog hierarchy.
                    var actionsDialog = findParentDialog(action);
                    if (actionsDialog) {
                        actionsDialog._childDialogs.push(this);
                        this._parentDialog = actionsDialog;
                    }
                    this._focusAndRefit(); // this is a legacy support

                    if (this.$.appConfig.mobile === true) { // mobile app specific: open all custom action dialogs in maximised state
                        this._invertMaximiseState();
                    }

                    this.open();
                }.bind(this), 200);
            },

            /**
             * Performes cleaning tasks in case where dialog opening should not occur.
             */
            _doNotOpen: function(resultsAppearedEvent, resultsDidNotAppearEvent) {
                this._clearOpeningListeners(resultsAppearedEvent, resultsDidNotAppearEvent);
                this._finishErroneousOpening();
            },

            /**
             * Performs tasks after erroneus completion of dialog's action execution.
             */
            _finishErroneousOpening: function() {
                this._setIsRunning(false);
                if (this._lastAction) {
                    this._lastAction.restoreActiveElement();
                }
            },

            /**
             * Removes listeners that open dialog for master-with-master and master-with-centre cases.
             */
            _clearOpeningListeners: function(resultsAppearedEvent, resultsDidNotAppearEvent) {
                if (this._openOnceConcrete && resultsAppearedEvent) {
                    this.removeEventListener(resultsAppearedEvent, this._openOnceConcrete);
                    this._openOnceConcrete = null;
                }
                if (this._doNotOpenConcrete && resultsDidNotAppearEvent) {
                    this.removeEventListener(resultsDidNotAppearEvent, this._doNotOpenConcrete);
                    this._doNotOpenConcrete = null;
                }
            },

            /**
             * Listener that listens binding entity appeared event and focuses first input.
             */
            _focusDialogWithInput: function(e) {
                // Desktop app specific: focus first input when opening dialog.
                // This is also used when closing dialog: if child dialog was not closed, then its first input should be focused (this however can not be reproduced on mobile due to maximised nature of all dialogs).
                // So, in mobile app the input will not be focused on dialog opening (and the keyboard will not appear suddenly until the user explicitly clicks on some editor).
                if (this.$.appConfig.mobile === false && this._lastElement.focusView) {
                    this._lastElement.focusView();
                }
            },

            /**
             * Listener that listens binding entity appeared event and refits loaded master.
             */
            _fitWhenFirstTimeOpened: function(e) {
                this.async(function() {
                    this.refit();
                }.bind(this), 50);
                this.removeEventListener('binding-entity-appeared', this._fitWhenFirstTimeOpened);
                this.removeEventListener('egi-entities-appeared', this._fitWhenFirstTimeOpened);
            },

            /**
             * Refits this dialog on async after 50 millis and focuses its input in case where 'binding-entity-appered' event has occured earlier than dialog .
             * A named function was used in favoir of an anonymous one in order to avoid accumulation of event listeners.
             */
            _focusAndRefit: function() {
                this.async(function() {
                    this.refit();
                }.bind(this), 50);
                this._focusDialogWithInput();
            },

            _dialogOpened: function(e, detail, source) {
                // the following refit does not always result in proper dialog centering due to the fact that UI is still being constructed at the time of opening
                // a more appropriate place for refitting is post entity binding
                // however, entity binding might not occure due to, for example, user authorisation restriction
                // that is why there is a need to perfrom refitting here as well as on entity binding
                this.async(function() {
                    this.refit();
                }.bind(this), 100);
                this._setIsRunning(false);
            },

            _dialogClosed: function(e) {
                var target = e.target || e.srcElement;
                if (target === this) {
                    // if there are current subscriptions they need to be unsubscribed
                    // due to dialog being closed
                    for (var index = 0; index < this._subscriptions.length; index++) {
                        postal.unsubscribe(this._subscriptions[index]);
                    }
                    this._resetAnimation();
                    this._subscriptions.length = 0;
                    this._wasMoved = false;
                    this._wasResized = false;
                    if (typeof this.heightBeforeResizing !== 'undefined' && typeof this.widthBeforeResizing !== 'undefined') { // restore original height / width after closing the dialog
                        this.style.height = this.heightBeforeResizing;
                        this.style.width = this.widthBeforeResizing;
                        delete this.heightBeforeResizing;
                        delete this.widthBeforeResizing;
                    }
                    this._minimised = false;
                    this._maximised = false;
                    this.$.menuToggler.hidden = true; // allows to use the same custom action dialog instance for the masters without menu after compound master was open previously

                    if (this._lastAction) {
                        this._lastAction.restoreActiveElement();
                    }
                }
            },
            
            _resetAnimation: function () {
                this._masterVisibilityChanges = undefined;
                this._masterLayoutChanges = undefined;
                this.$.elementLoader.style.removeProperty("display");
                this.$.loadingPanel.style.visibility = "hidden";
                this.$.dialogLoader.style.opacity = "1";
                this._resetSpinner();
            },

            _onIronResize: function() {
                if (!this._wasMoved && !this._wasResized && !this._minimised) {
                    Polymer.IronOverlayBehaviorImpl._onIronResize.call(this);
                }
            },

            /**
             * Returns 'true' if Restorer button of maximisation function is hidden, 'false' otherwise.
             */
            _maximiseRestorerHidden: function(_maximised, mobile) {
                return !_maximised || mobile === true;
            },

            /**
             * Returns 'true' if Closer button is hidden, 'false' otherwise.
             */
            _closerHidden: function(_lastAction, mobile) {
                return _lastAction.continuous || mobile === true;
            },

            /**
             * Returns 'true' if Collapser button of minimisation function is hidden, 'false' otherwise.
             */
            _collapserHidden: function(_minimised, mobile) {
                return _minimised || mobile === true;
            }
        });
    })();
</script>
