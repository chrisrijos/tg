<link rel="import" href="/resources/components/postal-lib.html">

<link rel="import" href="/resources/binding/tg-entity-binder-behavior.html">
<link rel="import" href="/resources/master/actions/tg-entity-master-closing-behavior.html">

<script>
    (function () {
        var SimultaneousSaveException = function () {
            Object.call(this);

            this.message = "Simultaneous save exception: the save process has been already started before and not ended. Please, block UI until the save action completes.";
        };
        SimultaneousSaveException.prototype = Object.create(Object.prototype);
        SimultaneousSaveException.prototype.constructor = SimultaneousSaveException;

        /**
         * Overridden toString method to represent this exception more meaningfully than '[Object object]'.
         *
         */
        SimultaneousSaveException.prototype.toString = function () {
            return this.message;
        }
        
        var selectEnabledEditor = function (editor) {
            var selectedElement = editor.querySelector('.custom-input:not([hidden]):not([disabled])');
            return (selectedElement && selectedElement.querySelector('textarea')) || selectedElement;
        }

        Polymer.TgBehaviors = Polymer.TgBehaviors || {};
        Polymer.TgBehaviors.TgEntityMasterBehaviorImpl = {
            properties: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                ////////////////////////////////////////// EXTERNAL PROPERTIES //////////////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                // These mandatory properties must be specified in attributes, when constructing descendant elements.  //
                // No default values are allowed in this case.														   //
                /////////////////////////////////////////////////////////////////////////////////////////////////////////

                /**
                 * The full java class name of the entity type. The entities of this type will be bound to this entity master.
                 */
                entityType: {
                    type: String
                },

                /**
                 * Custom callback that will be invoked after successfull saving.
                 *
                 * arguments: entity, bindingEntity, customObject
                 */
                postSaved: {
                    type: Function
                },

                /**
                 * Custom callback that will be invoked in case saving resulted in error.
                 *
                 * arguments: errorResult
                 */
                postSavedError: {
                    type: Function
                },

                /**
                 * Universal identifier of parent centre instance (used for pub / sub communication).
                 *
                 * Should be given from the outside of the element.
                 */
                centreUuid: {
                    type: String
                },

                /**
                 * The function to return 'master' entity (in case of this master being embedded into some other master).
                 *
                 * This 'master' entity is mainly used as a carrier of an entity id to be loaded by this master (this happens on observer).
                 */
                getMasterEntity: {
                    type: Function,
                    observer: '_getMasterEntityAssigned'
                },

                ////////////////////////////////////// SUBSECTION: NOT MANDATORY PROPERTIES //////////////////////////////////////

                /**
                 * The context in which save() action should be performed (it is not defined in case when context is not needed).
                 */
                savingContext: {
                    type: Object
                },

                /**
                 * The module where the master is located.
                 *
                 * This parameter is populated during dynamic loading of the master.
                 */
                moduleId: {
                    type: String
                },

                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                //////////////////////////////// INNER PROPERTIES, THAT GOVERN CHILDREN /////////////////////////////////
                /////////////////////////////////////////////////////////////////////////////////////////////////////////
                // These properties derive from other properties and are considered as 'private' -- need to have '_'   //
                //   prefix. 																				           //
                // Also, these properties are designed to be bound to children element properties -- it is necessary to//
                //   populate their default values in ready callback (to have these values populated in children)!     //
                /////////////////////////////////////////////////////////////////////////////////////////////////////////                

                /**
                 * Default implementation for postSaved callback.
                 */
                _postSavedDefault: {
                    type: Function
                },

                /**
                 * Default implementation for unsuccessful postSaved callback.
                 */
                _postSavedDefaultError: {
                    type: Function
                },

                /**
                 * The map of actions by their name ids.
                 *
                 * Every action consists of three callbacks ('preAction', 'postActionSuccess', 'postActionError') and
                 * 'shortDesc', 'longDesc', 'icon' + 'enabledStates'.
                 *
                 * 'EnabledStates' are the states in which the action is enabled.
                 */
                _actions: {
                    type: Object
                },

                /**
                 * Changes the state to 'EDIT'.
                 */
                edit: {
                    type: Function
                },

                /**
                 * Changes the state to 'VIEW'.
                 */
                view: {
                    type: Function
                },

                /**
                 * Starts the process of entity saving (based on _currBindingEntity).
                 *
                 * @param newContinuation -- newly appeared continuation [functional entity] to be stored for current initiating entity that is edited by this tg-entity-master
                 * @param continuationProperty -- property name identifier of newly appeared continuation
                 */
                save: {
                    type: Function
                },

                /**
                 * In case when this master represents a compound master and a new main entity has been just persisted, there is a need to augment the context of this master (i.e. this.savingContext) to be able to refresh the same context, but with just persisted entity (instead of only id).
                 *
                 * @param compoundMasterEntityId -- the id of just persisted main entity to be promoted into the context
                 */
                augmentContextWithSavedEntity: {
                    type: Function
                },

                /**
                 * The callback to strictly use for testing -- invokes after _ajaxSaver() has finished loading ('loading' property becomes 'false').
                 */
                _postSaverLoadingFinished: {
                    type: Function
                },

                /**
                 * Indicates whether the saver is loading.
                 */
                _saverLoading: {
                    type: Boolean,
                    observer: '_saverLoadingChanged'
                },

                /**
                 * The context holder creator (SavingInfoHolder) which is used for embedded views.
                 */
                _createContextHolderForEmbeddedViews: {
                    type: Function
                },

                /**
                 * The context holder creator (SavingInfoHolder) which is used for entity and property actions in the context of non-functional entity master.
                 */
                _createContextHolder: {
                    type: Function
                },
                
                /**
                 * The context holder creator (SavingInfoHolder) which is used for continuation actions in the context of non-functional entity master.
                 * The difference from '_createContextHolder' is only in aspect of parent context -- it always exists for continuation master entity.
                 */
                _createContextHolderForContinuations: {
                    type: Function,
                    notify: true
                },

                /**
                 * A dialog instance that is used for displaying entity (functional and not) masters as part of master actions logic.
                 * This dialog is of type tg-custom-action-dialog and gets created dynamically on attached event.
                 * Right away it is appended to document.body.
                 */
                _actionDialog: {
                    type: Object,
                    value: null
                },

                /**
                 * The function that shows dialog for functional action masters.
                 */
                _showDialog: {
                    type: Function
                },

                /**
                 * The entities retrieved when running centre that has this insertion point
                 */
                retrievedEntities: {
                    type: Array,
                    notify: true
                },
                /**
                 * Summary entity retrieved when running centre that has this insertion point.
                 */
                retrievedTotals: {
                    type: Object,
                    notify: true
                },
                
                /**
                 * Last updated entity selection in centre that has this insertion point's element.
                 */
                retrievedEntitySelection: {
                    type: Object,
                    notify: true
                },
                
                /**
                 * The function to map column properties of the entity to the form [{ dotNotation: 'prop1.prop2', value: '56.67'}, ...]. The order is 
                 * consistent with the order of columns.
                 *
                 * @param entity -- the entity to be processed with the mapper function
                 */
                columnPropertiesMapper: {
                    type: Function,
                    notify: true
                },

                shouldRefreshParentCentreAfterSave: {
                    type: Boolean,
                    value: true
                },
                
                /**
                 * The map of saved continuation functional entities by their property name identifiers.
                 *
                 * Continuation functional entity master pops-up after unsuccessful saving with concrete 'continuation' exception.
                 * After the user edits and saves continuation functional entity master -- the saved functional entity is stored 
                 * in this '_continuations' object.
                 *
                 * It is necessary to understand that '_continuations' are associated with the same 'saving' session for the same 
                 * 'initiating entity' and will be resetted after the success of the save (or after refresh, validate).
                 */
                _continuations: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                
                focusFirstInputBound: {
                    type: Function
                }
            },

            /**
             * Initialisation block. It has all children web components already initialised.
             */
            ready: function () {
                var self = this;
                
                self.focusFirstInputBound = self.focusFirstInput.bind(self);

                self._processSaverResponse = function (e) {
                    self._processResponse(e, "save", function (potentiallySavedOrNewEntity, exceptionOccured) {
                        self._provideExceptionOccured(potentiallySavedOrNewEntity, exceptionOccured);
                        return self._postSavedDefault(potentiallySavedOrNewEntity);
                    });
                };

                self._processSaverError = function (e) {
                    self._processError(e, "save", function (errorResult) {
                        return self._postSavedDefaultError(errorResult);
                    });
                };

                self._createActions();

                self._create_createContextHolder_function = (function (forContinuations) {
                    return (function (requireSelectionCriteria, requireSelectedEntities, requireMasterEntity, actionKind, actionNumber) {
                    
                        var getThisMasterEntity = function () {
                            var holder = this._extractModifiedPropertiesHolder(this._currBindingEntity, this._originalBindingEntity);

                            // @@funcEntityType is really a master entity type, which in this case is not functional!!!
                            var masterTypeCarrier = this.savingContext ? this.savingContext : this._reflector().createContextHolder(
                                null, null, forContinuations ? (this.getMasterEntity ? 'true' : null) : null,
                                null, null, forContinuations ? (this.getMasterEntity ? this.getMasterEntity : null) : null
                            );
                            this._reflector().setCustomProperty(masterTypeCarrier, "@@funcEntityType", this.entityType);
                            return this._reflector().createSavingInfoHolder(this._reset(holder), masterTypeCarrier, this._continuations);
                        }.bind(this);

                        var contextHolder = this._reflector().createContextHolder(
                            null, null, requireMasterEntity,
                            null, null, getThisMasterEntity
                        );
                    
                        this._reflector().setCustomProperty(contextHolder, "@@masterEntityType", this.entityType);
                        this._reflector().setCustomProperty(contextHolder, "@@actionKind", actionKind);
                        this._reflector().setCustomProperty(contextHolder, "@@actionNumber", actionNumber);
                    
                        return contextHolder;
                    }).bind(this);
                }).bind(self);
                
                self._createContextHolder = self._create_createContextHolder_function(false);

                // calbacks, that will potentially be augmented by tg-action child elements: 
                self._postSavedDefault = (function (potentiallySavedOrNewEntity) {
                    // 'potentiallySavedOrNewEntity' can have two natures:
                    //  1) fully fresh new entity from 'continuous creation' process (DAO object returns fully new entity after successful save of previous entity)
                    //    a) it has no id defined (id === null)
                    //    b) it can be valid (required properties can still be blue)
                    //    c) it can be invalid (in case when the logic of 'continuous creation' creates new entity as invalid)
                    //  2) saved or unsaved entity that was tryied to be saving
                    //    a) if valid == saving was successful and id should be defined (not 'null')
                    //    b) if invalid == id can be defined (when persisted entity was trying to be saved but with failure) or can be 'null' (when new entity was trying to be saved but with failure)

                    // 'isContinuouslyCreated' is calculated based on the fact that the newly created in DAO entity will be different from the entity that was bound previously
                    // by means of the keys assigned.
                    var isContinuouslyCreated = potentiallySavedOrNewEntity.type().isPersistent()
                        /* TODO && !this._currEntity.isPersisted() */
                        && !potentiallySavedOrNewEntity.isPersisted() && !this._reflector().equalsEx(this._currEntity, potentiallySavedOrNewEntity);

                    var msg = this._toastMsg("Operation", potentiallySavedOrNewEntity);
                    this._openToast(potentiallySavedOrNewEntity, msg, !potentiallySavedOrNewEntity.isValid() || potentiallySavedOrNewEntity.isValidWithWarning(), msg, false);

                    // isRefreshingProcess should be 'true' to reset old binding information in case where 'continuously created' entity arrive
                    var newBindingEntity = this._postEntityReceived(potentiallySavedOrNewEntity, isContinuouslyCreated);
                    
                    if (potentiallySavedOrNewEntity.isValidWithoutException()) {
                        // in case where successful save occured we need to reset @@touchedProps that are transported with bindingEntity
                        newBindingEntity["@@touchedProps"] = { names: [], counts: [] };
                    }

                    // custom external action
                    if (this.postSaved) {
                        this.postSaved.bind(this)(potentiallySavedOrNewEntity, newBindingEntity);
                    }

                    if (potentiallySavedOrNewEntity.isValidWithoutException()) {
                        // in case where overridden _resetState function will not be invoked it is necessary to reset _continuations after successful save
                        this._continuations = {};
                        
                        // Context creator should assigned only after successful master entity saving.
                        // In case of successful assignment it gets promoted to embedded views by means of binding.
                        this._createContextHolderForEmbeddedViews = (function () {
                            var holder = this._extractModifiedPropertiesHolder(this._currBindingEntity, this._originalBindingEntity);
                            this._reflector().setCustomProperty(this.savingContext, "@@funcEntityType", this.entityType);
                            return this._reflector().createSavingInfoHolder(this._reset(holder), this.savingContext, this._continuations);
                        }).bind(this);
                    }
                    
                    var _exceptionOccured = potentiallySavedOrNewEntity.exceptionOccured();
                    // if continuation exception has been occured -- find its 'tg-ui-action' and '_run' it (if it does not exist -- then it should be created)
                    if (_exceptionOccured !== null && _exceptionOccured.ex && _exceptionOccured.ex.continuationTypeStr) {
                        var continuationType = this._reflector().findTypeByName(_exceptionOccured.ex.continuationTypeStr); // continuation functional entity type
                        if (continuationType === null) {
                            throw 'Continuation type [' + _exceptionOccured.ex.continuationTypeStr + '] was not registered.';
                        }
                        var continuationProperty = _exceptionOccured.ex.continuationProperty; // the property name that uniquely identifies continuation in saving session of initiating entity on this master (will be set on companion object)
                        var elementName = 'tg-' + continuationType._simpleClassName() + '-master';
                        var actionDesc = continuationType._simpleClassName() + '-' + continuationProperty;
                        
                        var action = this.querySelector('tg-ui-action[continuation-property="' + continuationProperty + '"]');
                        if (!action) {
                            if (!this._createContextHolderForContinuations) {
                                this._createContextHolderForContinuations = this._create_createContextHolder_function(true);
                            }
                            var actionModel = document.createElement('template', 'dom-bind');
                            actionModel.innerHTML = 
                                "<tg-ui-action " +
                                     "hidden " +
                                     "id='continuationAction' " +
                                     "ui-role='BUTTON' " + // it does not matter -- hidden
                                     "short-desc='" + continuationType.entityTitle() + "' " +
                                     "long-desc='" + continuationType.entityDesc() + "' " +
                                     "icon='editor:mode-edit' " +
                                     // "should-refresh-parent-centre-after-save " + // is not needed -- continuation actions are the actions on tg-entity-master, this parameter is not applicable
                                     "component-uri='/master_ui/" + continuationType.fullClassName() + "' " +
                                     "continuation-property='" + continuationProperty + "' " +
                                     "element-name='" + elementName + "' " +
                                     // "number-of-action='...' " + // numberOfAction is not needed (it is used directly for compound master menu items and insertion points -- no intersection with continuations)
                                     "element-alias='" + elementName + "_" + continuationProperty + "_CONTINUATION' " +
                                     "show-dialog='[[_showDialog]]' " +
                                     "create-context-holder='[[_createContextHolderForContinuations]]' " +
                                     "attrs='[[attrs]]' " +
                                     "pre-action='[[preAction]]' " +
                                     "post-action-success='[[postActionSuccess]]' " +
                                     "post-action-error='[[postActionError]]' " +
                                     "require-selection-criteria='false' " +
                                     "require-selected-entities='NONE' " +
                                     "require-master-entity='true' " +
                                     "class='primary-action'> " +
                                 "</tg-ui-action>";
                            
                            Polymer.dom(this.root).appendChild(actionModel);
                            Polymer.dom.flush();
                            
                            action = actionModel.$.continuationAction;
                            
                            actionModel._showDialog = self._showDialog;
                            actionModel._createContextHolderForContinuations = self._createContextHolderForContinuations;
                            actionModel.primaryAction = self.primaryAction;
                            
                            actionModel.preAction = function (action) {
                                console.log('preAction: ' + actionDesc);
                                return Promise.resolve(true);
                            };
                            actionModel.postActionSuccess = function (functionalEntity) {
                                console.log('postActionSuccess: ' + actionDesc, functionalEntity);
                                self.save(functionalEntity, continuationProperty)
                                    .then(
                                        Polymer.TgBehaviors.TgEntityMasterClosingBehavior.createEntityActionThenCallback(self.centreUuid, 'save', postal, null),
                                        function (value) { console.log('AJAX PROMISE CATCH', value); }
                                    );
                            };
                            actionModel.postActionError = function (functionalEntity) {
                                console.log('postActionError: ' + actionDesc, functionalEntity);
                            };
                            actionModel.attrs = {
                                entityType:continuationType.fullClassName(), currentState:'EDIT', centreUuid: self.uuid
                            };
                            
                            // newly created continuation action should be enhanced to be able to enable parent master view after action completion (when isActionInProgress becomes false)
                            var old_actionProgressStatusChanged = action._actionProgressStatusChanged.bind(action);
                            var _self = this;
                            action._actionProgressStatusChanged = (function (newValue, oldValue) {
                                old_actionProgressStatusChanged(newValue, oldValue);
                                if (newValue === false) {
                                    _self.enableView();
                                }
                            }).bind(action);
                        }
                        action._run();
                    } else if (_exceptionOccured !== null) {
                        this.enableView();
                        
                        // in case where overridden _resetState function will not be invoked it is necessary to reset _continuations after unsuccessful save due to non-continuation exception
                        this._continuations = {};
                    } else {
                        this.enableView();
                    }

                    return potentiallySavedOrNewEntity.isValidWithoutException();
                }).bind(self);

                self._postSavedDefaultError = (function (errorResult) {
                    // This function will be invoked after server-side error appear.
                    // 'tg-action' will augment this function with its own '_afterExecution' logic (spinner stopping etc.).                	
                    console.warn("SERVER ERROR: ", errorResult);

                    // custom external action
                    if (this.postSavedError) {
                        this.postSavedError.bind(this)(errorResult);
                    }
                    this.enableView();
                }).bind(self);

                self.edit = (function () {
                    if (this.currentState === 'EDIT') {
                        console.warn("The master is already in EDIT state. state == ", this.currentState);
                    } else {
                        this.enableView();
                    }
                }).bind(self);

                self.view = (function () {
                    if (this.currentState === 'VIEW') {
                        console.warn("The master is already in VIEW state. state == ", this.currentState);
                    } else {
                        this.disableView();
                    }
                }).bind(self);

                self._createSavingPromise = (function () {
                    var holder = this._extractModifiedPropertiesHolder(this._currBindingEntity, this._originalBindingEntity);

                    // There is no need check at the client side whether _hasModified(holder).
                    // This check will be too restrictive from the perspective of developer-driven usage of 'save' method.
                    // It means that developer could perform manually saving of 'unmodified' entity for some reasons.
                    // However, please check the _bindingEntityModified property (tg-entity-binder-behavior) and its usage for more information.
                    return this._saveModifiedProperties(this._reset(holder));
                }).bind(self);

                self.save = (function (newContinuation, continuationProperty) {
                    this.disableView();
                    var self = this;
                    if (self._savingInProgress()) {
                        var SimultaneousSaveException = self._getSimultaneousSaveExceptionType();
                        throw new SimultaneousSaveException();
                    }
                    
                    // if continuation has been passed into saving function (in postSaveSuccess callback of continuation's tg-ui-action)
                    // then it should be stored locally in _continuations map.
                    if (newContinuation) {
                        this._continuations[continuationProperty] = newContinuation;
                    }

                    // cancel previous validation requests except the last one -- if it exists then saving process will be chained on top of that last validation process, 
                    // otherwise -- saving process will simply start immediately
                    var lastValidationPromise = self._validator().abortValidationExceptLastOne();
                    if (lastValidationPromise !== null) {
                        console.warn("Saving is chained to the last validation promise...");
                        return lastValidationPromise
                            .then(function () {
                                return self._createSavingPromise();
                            });
                    }
                    return self._createSavingPromise();
                }).bind(self);

                self.augmentContextWithSavedEntity = (function (compoundMasterEntityId) {
                    this._reflector().setCustomProperty(this.savingContext, "@@compoundMasterEntityId", compoundMasterEntityId);
                    console.log("augmentContextWithSavedEntity", compoundMasterEntityId);
                }).bind(self);

                self._postSaverLoadingFinished = (function () {
                    console.log("_postSaverLoadingFinished");
                }).bind(self);

                self._showDialog = (function (action) {
                    var closeEventChannel = self.uuid;
                    var closeEventTopics = ['save.post.success', 'refresh.post.success'];
                    this.async(function () {
                        this._actionDialog.showDialog(action, closeEventChannel, closeEventTopics);
                    }.bind(self), 1);
                }).bind(self);
            }, // end of ready callback

            attached: function () {
                var self = this;

                // we'd like to limit the number of dialogs created per entity master type
                // this way the same instance is reused by different master instances of the same type
                // that is why dialogs ID is defined as the master entity type
                // the dialog is never removed from document.body
                if (self._actionDialog == null) {
                    var dialog = document.body.querySelector('tg-custom-action-dialog[id="' + self.uuid + '"]');
                    if (dialog) {
                        self._actionDialog = dialog;
                    } else {
                        self._actionDialog = document.createElement('tg-custom-action-dialog');
                        Polymer.dom(self._actionDialog).setAttribute("id", self.uuid);
                        Polymer.dom(document.body).appendChild(self._actionDialog);
                        Polymer.dom.flush();
                    }
                }

            },
            
            _modificationsChanged: function (_bindingEntityNotPersistentOrNotPersistedOrModified, _editedPropsExist) {
                var self = this;
                var saveButton = self.$._saveAction;
                // console.debug('_bindingEntity self = ', self.is, 'self.$._saveAction = ', self.$._saveAction, '_bindingEntityNotPersistentOrNotPersistedOrModified', _bindingEntityNotPersistentOrNotPersistedOrModified, '_editedPropsExist', _editedPropsExist);
                if (saveButton) {
                    saveButton.outerEnabled = _editedPropsExist || _bindingEntityNotPersistentOrNotPersistedOrModified;
                }
            },

            /**
             * A callback that should be bound to on-after-load event in case of this master having an embedded master.
             * This is required in order to assign the postSaved and postSavedError handler calls to the embedded master, so
             * that it would act like it is the master and the wrapping master is just that -- a mere wrapper for providing context.
             */
            _assignPostSavedHandlersForEmbeddedMaster: function (e) {
                var embeddedMaster = e.detail;
                embeddedMaster.postSaved = this.postSaved;
                embeddedMaster.postSavedError = this.postSavedError;
            },

            /**
             * Looks for the first input that is not hidden and not disabled to focus it.
             */
            focusFirstInput: function () {
                this.async(function () {
                    var editors = this.querySelectorAll('tg-editor');
                    var editorIndex, firstInput, selectedElement;
                    for (editorIndex = 0; editorIndex < editors.length; editorIndex++) {
                        if (editors[editorIndex].offsetParent !== null) {
                            selectedElement = selectEnabledEditor(editors[editorIndex]);
                            firstInput = firstInput || selectedElement;
                            if (editors[editorIndex]._error && !editors[editorIndex].isInWarning()) {
                                if (selectedElement) {
                                    selectedElement.focus();
                                    return;
                                }
                            }
                        }
                    }
                    // if the input has been identified then focus it, otherwise do nothing
                    if (firstInput) {
                    	firstInput.focus();
                    }
                }.bind(this), 100);
            },

            /**
             * Creates default master actions.
             */
            _createActions: function () {
                var self = this;
                self._actions = {};

                self._actions['REFRESH'] = {
                    shortDesc: 'REFRESH',
                    longDesc: 'REFRESH ACTION...',
                    enabledStates: ['EDIT', 'VIEW'],
                    action: function () {
                        return self.retrieve();
                    }
                };
                self._notifyActionPathsFor('REFRESH', true);
                self._actions['VALIDATE'] = {
                    shortDesc: 'VALIDATE',
                    longDesc: 'VALIDATE ACTION...',
                    enabledStates: ['EDIT'],
                    action: function () {
                        self.validate();
                    }
                };
                self._notifyActionPathsFor('VALIDATE', true);
                self._actions['SAVE'] = {
                    shortDesc: 'SAVE',
                    longDesc: 'SAVE ACTION...',
                    enabledStates: ['EDIT'],
                    action: function () {
                        return self.save();
                    }
                };
                self._notifyActionPathsFor('SAVE', true);

                self._actions['EDIT'] = {
                    shortDesc: 'EDIT',
                    longDesc: 'EDIT ACTION...',
                    enabledStates: ['VIEW'],
                    action: function () {
                        self.edit();
                        this.postAction(null);
                    },
                    postAction: function (e) {}
                };
                self._notifyActionPathsFor('EDIT', false);

                /* self.set('_actions.VIEW', {});
                self.set('_actions.VIEW.shortDesc', 'VIEW');
                self.set('_actions.VIEW.longDesc', 'VIEW ACTION...');
                self.set('_actions.VIEW.enabledStates', ['EDIT']);
                self.set('_actions.VIEW.action', function () {
                    self.view();
                    this.postAction(null);
                });
                self.set('_actions.VIEW.postAction', function (e) {                	
                }); */

                self._actions['VIEW'] = {
                    shortDesc: 'VIEW',
                    longDesc: 'VIEW ACTION...',
                    enabledStates: ['EDIT'],
                    action: function () {
                        self.view();
                        this.postAction(null);
                    },
                    postAction: function (e) {}
                };
                self._notifyActionPathsFor('VIEW', false);
            },

            /**
             * Notifies all the paths of newly promoted action with concrete name (this is necessary for binding to child elements).
             */
            _notifyActionPathsFor: function (actionName, withoutPostAction) {
                var path0 = '_actions.' + actionName;
                var action0 = this._actions[actionName];

                this.notifyPath(path0, action0); // notify root
                this.notifyPath(path0 + ".shortDesc", action0.shortDesc);
                this.notifyPath(path0 + ".longDesc", action0.longDesc);
                this.notifyPath(path0 + ".enabledStates", action0.enabledStates);
                this.notifyPath(path0 + ".action", action0.action);
                if (!withoutPostAction) {
                    this.notifyPath(path0 + ".postAction", action0.postAction);
                }
                // TODO postActionError?
            },

            /**
             * The tg-entity-validator component for entity validation.
             */
            _validator: function () {
                throw "_validator: not implemented";
            },

            /**
             * The ajax-saver component.
             */
            _ajaxSaver: function () {
                throw "_ajaxSaver: not implemented";
            },

            /** 
             * The function for binding property title -- entity.type().prop(property).title(). The argument 'entity' will be changed in future. Polymer will listen to that change.
             * The function for binding property desc -- entity.type().prop(property).desc(). The argument 'entity' will be changed in future. Polymer will listen to that change.
             */

            //////////////////////////////////////// VALIDATION ////////////////////////////////////////
            /**
             * Overridden to reuse this.savingContext. It is not empty for tg-ui-action's functional entities, which is assigned in its method _onExecuted.
             */
            _validateForDescendants: function (preparedModifHolder) {
                if (this.getMasterEntity && !this.savingContext) {
                    var contextHolder = this._reflector().createContextHolder(
                        null, null, 'true',
                        null, null, this.getMasterEntity);

                    return this._validator().validate(preparedModifHolder, contextHolder);
                } else {
                    return this._validator().validate(preparedModifHolder, this.savingContext);
                }
            },

            //////////////////////////////////////// SAVING ////////////////////////////////////////
            _savingInProgress: function () {
                return this._ajaxSaver().loading;
            },
            
            /**
             * Overridden from tg-entity-binder-behavior to reset _continuations.
             */
            _resetState: function () {
                Polymer.TgBehaviors.TgEntityBinderBehavior._resetState.call(this);
                // need to reset _continuations after 'refresh', 'continuous saving'. See also _postSavedDefault for specific resetting after save. See also _postValidatedDefault for resetting after validation.
                this._continuations = {};
            },

            /**
             * Starts the process of entity saving.
             *
             * @param modifiedPropertiesHolder -- the entity with modified properties
             */
            _saveModifiedProperties: function (modifiedPropertiesHolder) {
                if (this.getMasterEntity && !this.savingContext) {
                    var contextHolder = this._reflector().createContextHolder(
                        null, null, 'true',
                        null, null, this.getMasterEntity);

                    this._ajaxSaver().body = JSON.stringify(this._serialiser().serialise(this._reflector().createSavingInfoHolder(modifiedPropertiesHolder, contextHolder, this._continuations)));
                } else {
                    this._ajaxSaver().body = JSON.stringify(this._serialiser().serialise(this._reflector().createSavingInfoHolder(modifiedPropertiesHolder, this.savingContext, this._continuations)));
                }
                return this._ajaxSaver().generateRequest().completes;
            },

            /**
             * Method implementing .canLeave contract as disignated in classList.
             * It is used to identify whether master can be "left/closed" without any adverse effect on the data it represents (i.e. there was no unsaved changes).
             */
            canLeave: function () {
                // check all the child nodes with canLeave contract if they can be left...
                var nodesWithCanLeave = this.querySelectorAll('.canLeave');
                if (nodesWithCanLeave.length > 0) {
                    for (var index = 0; index < nodesWithCanLeave.length; index++) {
                        var reason = nodesWithCanLeave[index].canLeave();
                        if (reason !== undefined) {
                            return reason;
                        }
                    }
                }

                if (this.classList.contains('canLeave')) {
                    // The master can be left in case where there is no modifications and the entity is not new and the entity is not persistent. 
                    // Refer to _bindingEntityNotPersistentOrNotPersistedOrModified property of tg-entity-binder-behavior for more information.
                    if (this._editedPropsExist || this._bindingEntityNotPersistentOrNotPersistedOrModified) {
                        if (this._currBindingEntity.id === null) {
                            return {
                                isNew: true,
                                msg: "A new entity is being created. Please save your changes."
                            };
                        } else {
                            return {
                                isNew: undefined, // this could be not persistent entity (new) or persistent persisted entity (not new)
                                msg: "Please save or cancel your changes."
                            };
                        }
                    }
                }
                return undefined;
            },

            //////////////////////////////////////// BINDING & UTILS ////////////////////////////////////////
            _getSimultaneousSaveExceptionType: function () {
                return SimultaneousSaveException;
            },

            _saverLoadingChanged: function (newValue, oldValue) {
                console.log("_saverLoadingChanged:", newValue, oldValue);
                if (oldValue === true && newValue === false) {
                    this._postSaverLoadingFinished();
                }
            },

            _getMasterEntityAssigned: function () {
                var self = this;

                self.entityId = 'find_or_new';
                self.retrieve(self.getMasterEntity());
            },

            /** 
             * This method is used to drive the master visibility and auto-run logic.
             */
            shouldSkipUi: function () {
                return typeof this._currBindingEntity['skipUi'] !== 'undefined' &&
                    this._currBindingEntity['skipUi'] === true;
            },

            /** A helper method to assist in making the caching decision. Used as an optimisation technique. */
            canBeCached: function () {
                return typeof this._currBindingEntity['skipUi'] === 'undefined';
            }
        };

        Polymer.TgBehaviors.TgEntityMasterBehavior = [
            Polymer.TgBehaviors.TgEntityBinderBehavior,
            Polymer.TgBehaviors.TgEntityMasterBehaviorImpl
        ];

    })();
</script>