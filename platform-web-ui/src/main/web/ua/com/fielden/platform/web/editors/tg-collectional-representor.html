<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/reflection/tg-polymer-utils.html">
<link rel="import" href="/resources/editors/tg-editor-behavior.html">
<link rel="import" href="/resources/editors/tg-editor.html">

<link rel="import" href="/resources/polymer/iron-input/iron-input.html">

<dom-module id="tg-collectional-representor">
    <style>
        #input[disabled] {
            cursor: text;
        }
    </style>
    <template>
    	<tg-editor
    		id="editorDom"
    		prop-title="[[propTitle]]"
    		_disabled="[[_disabled]]"
    		_editing-value="{{_editingValue}}"
    		action="[[action]]"
    		_error="[[_error]]"
    		_comm-value="[[_commValue]]"
    		_accepted-value="[[_acceptedValue]]"
    		debug="[[debug]]">
			<input
                id="input"
                class="custom-input collectional-representor-input"
                is="iron-input"
                bind-value="{{_editingValue}}"
                on-change="_onChange"
                on-input="_onInput"
                on-keydown="_onKeydown"
                on-tap="_onTap"
                on-mousedown="_onTap"
                disabled$="[[_disabled]]"
                tooltip-text$="[[_getTooltip(_editingValue, entity)]]"/>
        	<content class=".property-action"></content>
    	</tg-editor>
    </template>
</dom-module>

<script>
    Polymer({
        is: 'tg-collectional-representor',
        behaviors: [Polymer.TgBehaviors.TgEditorBehavior],

        /**
         * Converts the value into string representation (which is used in edititing / comm values).
         */
        convertToString: function(value) {
            if (value === null) {
                return "";
            }

            if (value.constructor !== Array) {
                throw 'Unsupported value has appeared inside collectional representor: ' + value;
            }

            const fullEntity = this.reflector()._getValueFor(this.entity, "");
            const originValue = fullEntity.get(this.propertyName);
            if (originValue.length === 0 || !originValue[0].type().isCompositeEntity()) {
                return value.map(v => this.reflector().convert(v)).join(", "); // assumes that value is array of entities
            } else {
                return this.reflector().convert(generateShortCollection(fullEntity, this.propertyName, originValue[0].type())).join(", ");
            }
        },

        /**
         * This method promotes 'IRRELEVANT' into _acceptedValue which should not be a problem, since this 'representor' is not editable at all.
         */
        convertFromString: function(strValue) {
            return 'IRRELEVANT';
        },

        /**
         * This 'representor' is disabled for editing (just gives a view of the entity collection).
         */
        _isDisabled: function(currentState, bindingEntity, propertyName) {
            return true;
        },
        
        _getTooltip: function(_editingValue, entity) {
            if (entity !== null) {
                const fullEntity = this.reflector()._getValueFor(entity, "");
                let valueToFormat = "";
                if (this.reflector().isError(fullEntity.prop(this.propertyName).validationResult())) {
                    valueToFormat = _editingValue;
                } else {
                    valueToFormat = this.reflector()._getValueFor(entity, this.propertyName);
                }
                return Polymer.TgBehaviors.TgEditorBehavior._getTooltip.call(this, valueToFormat);
            }
            return "";
        },
        
        _formatTooltipText: function (valueToFormat) {
            if (valueToFormat !== null) {
                if (Array.isArray(valueToFormat)) {
                    if (valueToFormat.length === 0 || !valueToFormat[0].type().isCompositeEntity()) {
                        return valueToFormat.length > 0 ? ("<b>" + valueToFormat.join(", ") + "</b>") : '';
                    } else {
                        const collection = generateShortCollection(this.reflector()._getValueFor(this.entity, ""), this.propertyName, valueToFormat[0].type());
                        const title = this.reflector().convert(collection).join(", ");
                        const desc = collection.reduce((curr, next) => this.reflector().isEntity(next) && next.get("desc") ? curr + (curr ? ", " : "") + next.get("desc") : curr, "");
                        return "<b>" + title + "</b>" + (desc ? "<br>" + desc : "");
                    }
                } else {
                    throw 'Unsupported value has appeared inside collectional representor: ' + valueToFormat;
                }
            }
            return '';
        }
    });
</script>
