<link rel="import" href="/resources/polymer/polymer/polymer.html">
<link rel="import" href="/resources/polymer/paper-styles/color.html">

<link rel="import" href="/resources/components/tg-tooltip-behavior.html">
<link rel="import" href="/resources/file_operations/tg-attachment-uploader.html">

<dom-module id="tg-attachment-uploader-list">
	<template>
		<style>
			:host {
				display: inline-block;
				position: relative;
				box-sizing: border-box;
				text-align: center;
				font: inherit;
				outline: none;
				-moz-user-select: none;
				-ms-user-select: none;
				-webkit-user-select: none;
				user-select: none;
			}

			.over {
				background: var(--paper-green-100);
			}

			#fileSelect {
				cursor: pointer;
			}

			#container {
				display: flex;
				flex-direction: column;
				overflow: auto;
				border:1px dashed #ff5555;
				padding: 8px;
			}
			
		</style>

		<div id="container" style="width:100%" on-tap='_openFileDialog' on-dragenter='_dragenter' on-dragover='_dragover' on-dragleave='_dragleave' on-drop='_drop'>
			<template is='dom-repeat' id='uploaders' items='[[_filesToUpload]]' as='f'>
				<tg-attachment-uploader style='width: 100%'
					id$='[[_makeId(index)]]'
					list-index='[[index]]'
					file='[[f]]'
					url='[[url]]'
					upload-size-limit-kb='[[uploadSizeLimitKb]]'
					mime-types-accepted='[[mimeTypesAccepted]]'
					process-uploading-stopped='[[_perUploaderListenerOnUploadingStopped]]'></tg-attachment-uploader>
			</template>
		</div>

	</template>
</dom-module>

<script>
(function () {
	Polymer({
		is: 'tg-attachment-uploader-list',

		behaviors: [Polymer.TgBehaviors.TgTooltipBehavior],

		properties: {
			/* If enabled will output names, number, total size and mime types of the selected files. */
			debug: {
				type: Boolean,
				value: false
			},
		    
			/* URI that points to a file processing resource. */
			url: {
				type: String,
			},

			/* The limit of data to be uploaded for processing in Kibibytes. */
			uploadSizeLimitKb: {
				type: Number,
				value: 20480 // 20 Mebibyte
			},

			/* Acceptable mime types for the files to be uploaded. */
			mimeTypesAccepted: {
				type: String,
				value: '*/*',
				observer: '_mimeTypesAcceptedChanged'
			},
		    
			/* A callback, which gets invoked when uploading of all files stopped, either due to success, error or abortion. */
			processUploadingStopped: {
			    type: Function
			},
			
			numberOfUploaded: {
			    type: Function
			},
			
			numberOfFailed: {
			    type: Function
			},

			numberOfAborted: {
			    type: Function
			},
			
			_uploadInput: {
				type: Object,
			},
			
            /* An array of files that need to be uploaded.
             * Should NOT be manipulated directly -- only via methods pushValue.*/
            _filesToUpload: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            
    			_perUploaderListenerOnUploadingStopped: {
    			    type: Function,
    			    value: function() {
	    			    return function(uploader) {
			    		    console.log("UPLOADER STOPPED FOR index=", uploader.listIndex, 'id=', uploader.id);
			    		    
			    		    // if the uploader is not the last element then the next uploader needs to start uploading
			    		    if (uploader.listIndex < this.$.uploaders.items.length - 1) {
			    		        const nextId = this._makeId(uploader.listIndex+1);
				    		    const elem = Polymer.dom(this.root).querySelector("#" + nextId);
				    		    console.log("NEXT UPLOADER:", elem);
				    		    if (elem) {
				    		        elem.canUpload = true;
				    		    }
			    		    }
			    		    
			    		    if (this.processUploadingStopped) {
			    		        this.processUploadingStopped(uploader);
			    		    }
	    			    }.bind(this);
    			    }
    			},
    			
    			uploadersRenderedItemCountChanged: { 
    			    type: Function,
    			    value: function() {
    			        return function() {
    			   					console.log("RENDERED ITEMS COUNT:", this.$.uploaders.renderedItemCount);
    					}.bind(this);
    			    }
    			}

		},
		
		created: function() {
			// let's create an invisible file input element to be used for opening a file dialog
			this._uploadInput = document.createElement('input');
			this._uploadInput.type = 'file';
			this._uploadInput.setAttribute('multiple', ''); // support multiple files
			this._uploadInput.onchange = function() {
			    this.submitUploading(this._uploadInput.files);
			}.bind(this);
		},
		
		ready: function() {
			this.numberOfUploaded = function () {
			    return 1;
			}

			this.numberOfFailed = function () {
			    return 1;
			}

			this.numberOfAborted = function () {
			    return 1;
			}
		},
		
		/**
         * Makes a value for attribute id based on the provided index.
         * Such id values are used for <tg-attachment-uploader> HTML elements representing list of files for upload. 
         */
		_makeId: function(index) {
		    const id = "tg-attachment-uploader-" + index;
			return id;
		},
		
        /* Pushes the specified file into the tail of attay _filesToUpload, which triggers its uploading */
        _pushFileForUpload: function(file) {
            this.push('_filesToUpload', file);
        },
        
        /* A function to be bound to on-tap of some visual element, trigerring openning of a file dialog to choose file for uploading */
		_openFileDialog: function(e) {
			// let give a chance for tap animation to do its work
			this.async(function() {
				if (this._uploadInput) {
					this._uploadInput.click();
				} else {
					throw new Error('this._uploadInput is not defined!');
				}
			}.bind(this), 200);
		},

		/* Function responsible for submitting files into the queue for uploading. */
		submitUploading: function(fileList) {
			const self = this;
			Array.from(fileList).forEach( file => self._pushFileForUpload(file) );
		},

		_mimeTypesAcceptedChanged: function(newValue, oldValue) {
			this._uploadInput.setAttribute('accept', newValue);
		},

		_dragenter: function(e) {
			e.stopPropagation();
			e.preventDefault();

			this.classList.add('over');
		},

		_dragover: function(e) {
			e.stopPropagation();
			e.preventDefault();
			
			this.classList.add('over');
		},

		_dragleave: function(e) {
			e.stopPropagation();
			e.preventDefault();
			
			this.classList.remove('over');
		},

		_drop: function(e) {
			e.stopPropagation();
			e.preventDefault();
			this.classList.remove('over');

			this.submitUploading(e.dataTransfer.files);
		}

	});
})();
</script>
