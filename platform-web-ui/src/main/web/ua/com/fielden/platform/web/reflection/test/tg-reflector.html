<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>tg-reflector basic tests</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	
	<script src="/resources/polymer/@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src='/resources/polymer/web-animations-js/web-animations-next-lite.min.js'></script>
    <script src="/resources/filesaver/FileSaver.min.js"></script>
    <script src="/resources/polymer/wct-browser-legacy/browser.js"></script>
</head>

<body>
	<tg-reflector id="reflector"></tg-reflector>

    <script type="module">

        import '/app/tg-reflector.js';

        suite('reflector\'s', function() {
            let reflector;
            const typeName1 = 'ua.com.fielden.platform.sample.domain.TgPersistentEntityWithProperties';
            const typeName2 = 'ua.com.fielden.platform.sample.domain.TgPersistentCompositeEntity';
            const typeName3 = 'ua.com.fielden.platform.sample.domain.TgBogieLocation';
            const typeName4 = 'ua.com.fielden.platform.sample.domain.TgWorkshop';
            const typeName5 = 'ua.com.fielden.platform.sample.domain.TgWagonSlot';
            const typeName6 = 'ua.com.fielden.platform.sample.domain.TgWagon';
            
            setup(function() {
                reflector = document.querySelector('#reflector');
            });
            
            // Testing the access to 'key' property of different kinds of entities.
            // This property is of high importance and should be much in sync with server-side implementation.
            // At this stage only equality and toString implementation is used when accessing properties.
            // However client-side code is not restricted to that.
            
            /////////////////////// entity.get('key') tests ///////////////////////
            test('test empty object convertion should be fine', function (done) {
                assert.deepEqual(reflector.tg_convert({}), {});
                done();
            });
            
            test('test object with arbitrary properties convertion should not be acceptable', function (done) {
                try {
                    reflector.tg_convert({testProp: "testProp"});
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access is forbidden if not fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                try {
                    e1.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: key access returns concrete value if fetched', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                assert.strictEqual(e1.get('key'), 'DEMO01');
                done();
            });
            
            test('simple entity: equality comparison is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1); // key is not fetched
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: equality comparison succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO01';
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('simple entity: conversion is forbidden if key is not fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                try {
                    reflector.tg_convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('simple entity: conversion succeeds if key is fetched', function (done) {
                const entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                
                assert.strictEqual(reflector.tg_convert(entity1), 'DEMO01');
                done();
            });
            
            test('composite entity: key access returns DynamicEntityKey instance for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: key access also returns DynamicEntityKey instance for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                assert.strictEqual(entity1.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('composite entity: equality comparison is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                try {
                    reflector.equalsEx(entity1, entity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: equality comparison succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                const entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), true);
                done();
            });
            
            test('composite entity: conversion is forbidden for partly-fetched composite keys', function (done) {
                const entity1 = reflector.newEntity(typeName2);
                entity1.key2 = 7; // key1 is not fetched
                try {
                    reflector.tg_convert(entity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('composite entity: conversion succeeds for fully-fetched composite keys', function (done) {
                const e1 = reflector.newEntity(typeName1);
                e1.key = 'DEMO01';
                const entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                
                assert.strictEqual(reflector.tg_convert(entity1), 'DEMO01 7');
                done();
            });
            
            test('union entity: key access for empty union entity returns empty value', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                
                assert.strictEqual(uEntity.get('key'), null);
                done();
            });
            
            test('union entity: equality comparison succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion succeeds for empty union entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (no active entity)
                assert.strictEqual(reflector.tg_convert(uEntity1), null);
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity.workshop = workshop1;
                
                assert.strictEqual(uEntity.get('key'), 'W1');
                done();
            });
            
            test('union entity: equality comparison for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop2;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with simple entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                workshop1.key = 'W1';
                uEntity1.workshop = workshop1;
                
                assert.strictEqual(reflector.tg_convert(uEntity1), 'W1');
                done();
            });
            
            test('union entity: key access for union entity with composite entity being active returns key of this active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                assert.strictEqual(reflector.equalsEx(uEntity1, uEntity2), true);
                done();
            });
            
            test('union entity: conversion for union entity with composite entity being active succeeds', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon1 = reflector.newEntity(typeName6); // TgWagon
                wagon1.key = 'WAG1';
                wagonSlot1.wagon = wagon1;
                wagonSlot1.position = 7;
                uEntity1.wagonSlot = wagonSlot1;
                
                assert.strictEqual(reflector.tg_convert(uEntity1), 'WAG1 7');
                done();
            });
            
            test('union entity: key access for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity.workshop = workshop1;
                
                try {
                    uEntity.get('key');
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: equality comparison for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop2 = reflector.newEntity(typeName4); // TgWorkshop
                workshop2.key = 'W1';
                uEntity2.workshop = workshop1;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with simple entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (simple active entity)
                const workshop1 = reflector.newEntity(typeName4); // TgWorkshop
                uEntity1.workshop = workshop1;
                
                try {
                    reflector.tg_convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: key access for union entity with composite entity being active succeeds for partly-fetched active entity', function (done) {
                const uEntity = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity.wagonSlot = wagonSlot1;
                
                assert.strictEqual(uEntity.get('key') instanceof reflector.getDynamicEntityKeyPrototype(), true);
                done();
            });
            
            test('union entity: equality comparison for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                const uEntity2 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot2 = reflector.newEntity(typeName5); // TgWagonSlot
                const wagon2 = reflector.newEntity(typeName6); // TgWagon
                wagon2.key = 'WAG1';
                wagonSlot2.wagon = wagon2;
                wagonSlot2.position = 7;
                uEntity2.wagonSlot = wagonSlot2;
                
                try {
                    reflector.equalsEx(uEntity1, uEntity2);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            test('union entity: conversion for union entity with composite entity being active is forbidden for partly-fetched active entity', function (done) {
                const uEntity1 = reflector.newEntity(typeName3); // TgBogieLocation union entity (composite active entity)
                const wagonSlot1 = reflector.newEntity(typeName5); // TgWagonSlot
                wagonSlot1.position = 7; // wagon is not fetched
                uEntity1.wagonSlot = wagonSlot1;
                
                try {
                    reflector.tg_convert(uEntity1);
                    assert.fail('Strict proxy exception is required.');
                } catch (ex) {
                    done();
                }
            });
            
            /////////////////////// entity.get('key') tests [END] /////////////////
            
            test('equalsEx method works for regular values', function (done) {
                assert.strictEqual(reflector.equalsEx('ok', 'ok'), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx('ok', 'not_ok'), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for money values', function (done) {
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, null), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, {}), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 44.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, taxPercent: null }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD', taxPercent: null }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx(null, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({}, { amount: 45.6 }), false);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6 }, { amount: 45.6, currency: 'AUD' }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD' }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, taxPercent: null }, { amount: 45.6 }), true);
                assert.strictEqual(reflector.equalsEx({ amount: 45.6, currency: 'AUD', taxPercent: null }, { amount: 45.6 }), true);
                
                done();
            });
            
            test('equalsEx method works for colour values', function (done) {
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, null), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44338' }), false);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }, { hashlessUppercasedColourValue: 'F44336' }), true);
                assert.strictEqual(reflector.equalsEx({ hashlessUppercasedColourValue: 'F44336' }, { hashlessUppercasedColourValue: 'F44336', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx(null, { hashlessUppercasedColourValue: 'F44336' }), false);
                assert.strictEqual(reflector.equalsEx({}, { hashlessUppercasedColourValue: 'F44336' }), false);
                
                done();
            });
            
            test('equalsEx method works for hyperlink values', function (done) {
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, undefined), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, null), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, {}), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.au' }), false);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua', redundantProp: '3' }, { value: 'https://fielden.com.ua' }), true);
                assert.strictEqual(reflector.equalsEx({ value: 'https://fielden.com.ua' }, { value: 'https://fielden.com.ua', redundantProp: '3' }), true);
                
                assert.strictEqual(reflector.equalsEx(undefined, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx(null, { value: 'https://fielden.com.ua' }), false);
                assert.strictEqual(reflector.equalsEx({}, { value: 'https://fielden.com.ua' }), false);
                
                done();
            });
            
            test('equalsEx method works for falsey values', function (done) {
                assert.strictEqual(reflector.equalsEx(null, null), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(undefined, undefined), true, "Equal values should return 'true' from equalsEx method.");
                assert.strictEqual(reflector.equalsEx(null, undefined), false, "Not equal values should return 'false' from equalsEx method.");
                
                done();
            });
            
            test('equalsEx method works for entity values', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                var entity2 = reflector.newEntity(typeName2);
                var entity3 = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, null), false, "The non-empty entity should be not equal to 'null'.");
                assert.strictEqual(reflector.equalsEx(undefined, entity1), false, "'undefined' value should be not equal to non-empty entity.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1), true, "The same entity references should be equal.");
                
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different types should be not-equal.");
                
                done();
            });
            
            /**
             * Creates and registers new generated type with base type defined by 'baseTypeName'. It works through deep copying process of base type's EntityType instance and enhancing its full class name and identifier.
             */
            const createGenTypeFrom = function (baseTypeName, uuid, identifierSuffix) {
                const baseType = reflector.getType(baseTypeName); // take EntityType instance
                const genTypeRaw = JSON.parse(JSON.stringify(baseType)); // deep copy it, loosing EntityType and EntityTypeProp prototypes inside copied structure
                const genTypeName = baseTypeName + '$$TgEntity_' + uuid; // create new full class name
                genTypeRaw.key = genTypeName; // and assign it into raw entity type object
                genTypeRaw._identifier = genTypeName + identifierSuffix; // also assign _identifier for completness
                const genType = reflector.registerEntityType(genTypeRaw); // then register new type using raw object and mutating it into fully fledged EntityType with EntityTypeProps inside
                return genType;
            };
            
            test('equalsEx method works for entity values with generated types', function (done) {
                const baseType = reflector.getType(typeName1);
                const identifierSuffix = ':ua.com.fielden.platform.ui.menu.sample.MiDetailsCentre:';
                
                const entity1 = reflector.newEntity(baseType.fullClassName());
                entity1.key = 'DEMO00';
                
                const genType1 = createGenTypeFrom(baseType.fullClassName(), '75a5512fa9114da6bff0389d4d70f77a', identifierSuffix);
                
                const entity2 = reflector.newEntity(genType1.fullClassName());
                entity2.key = 'DEMO00';
                const entity2Copy = reflector.newEntity(genType1.fullClassName());
                entity2Copy.key = 'DEMO00';
                
                const genType1Copy = createGenTypeFrom(baseType.fullClassName(), '75a5512fa9114da6bff0389d4d70f77a', identifierSuffix);
                
                const entity3 = reflector.newEntity(genType1Copy.fullClassName());
                entity3.key = 'DEMO00';
                
                const genType2 = createGenTypeFrom(baseType.fullClassName(), 'd2ab2cbfa62c478a82405d4241e1cfa8', identifierSuffix);
                
                const entity4 = reflector.newEntity(genType2.fullClassName());
                entity4.key = 'DEMO00';
                
                assert.strictEqual(reflector.equalsEx(entity2, entity2Copy), true, 'Entities with exactly the same type reference should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity3), true, 'Entities with same generated type, but with different references to that type, should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity4), true, 'Entities with different generated types, that are generated from the same base type, should be equal.');
                assert.strictEqual(reflector.equalsEx(entity2, entity1), true, 'entity1 with generated type should be equal to entity2 with the type, that represents a base type for entity1\'s type.');
                
                done();
            });
            
            test('isEntity method works for falsey values', function (done) {
                assert.strictEqual(reflector.isEntity(null), false, "'null' should not be 'is entity'.");
                assert.strictEqual(reflector.isEntity(undefined), false, "'undefined' should not be 'is entity'.");
                
                done();
            });
            
            test('equalsEx method works for entity values with regular keys', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for entity values with composite keys', function (done) {
                var e1 = reflector.newEntity(typeName1); e1.key = 'DEMO01';
                var e1copy = reflector.newEntity(typeName1); e1copy.key = 'DEMO01';
                
                var entity1 = reflector.newEntity(typeName2);
                entity1.key1 = e1;
                entity1.key2 = 7;
                var entity2 = reflector.newEntity(typeName2);
                entity2.key1 = e1;
                entity2.key2 = 9;
                var entity1copy = reflector.newEntity(typeName2);
                entity1copy.key1 = e1copy;
                entity1copy.key2 = 7;
                var entityWithoutKey = reflector.newEntity(typeName2);
                entityWithoutKey.key2 = 7;
                
                assert.strictEqual(reflector.equalsEx(entity1, entity1copy), true, "Entities with same composite keys should be equal.");
                assert.strictEqual(reflector.equalsEx(entity1, entity2), false, "Entities with different composite keys should be not equal.");
                
                try {
                    reflector.equalsEx(entity1, entityWithoutKey);
                    assert.fail('Second entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                try {
                    reflector.equalsEx(entityWithoutKey, entity1);
                    assert.fail('First entity should cause failure during comparison, the \'key1\' property is not defined.');
                } catch (msg) {
                    console.log(msg);
                }
                
                done();
            });
            
            test('equalsEx method works for arrays', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                entity1.key = 'DEMO01';
                var entity2 = reflector.newEntity(typeName1);
                entity2.key = 'DEMO02';
                var entity1copy = reflector.newEntity(typeName1);
                entity1copy.key = 'DEMO01';
                var entityWithoutKey = reflector.newEntity(typeName1);
                
                assert.strictEqual(reflector.equalsEx([], null), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(null, []), false, "Null should not be equal to array.");
                assert.strictEqual(reflector.equalsEx([], undefined), false, "Array should not be equal to null.");
                assert.strictEqual(reflector.equalsEx(undefined, []), false, "Null should not be equal to array.");
                var arr1 = [];
                var arr1copy = [];
                assert.strictEqual(reflector.equalsEx(arr1, arr1), true, "Array should be equal to itself.");
                assert.strictEqual(reflector.equalsEx(arr1, arr1copy), true, "Two empty arrays should be equal.");
                var arr2 = [entity1];
                assert.strictEqual(reflector.equalsEx(arr1, arr2), false, "Non-empty array should not be equal to empty.");
                assert.strictEqual(reflector.equalsEx(arr2, arr1), false, "Non-empty array should not be equal to empty.");
                var arr2copy = [entity1];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy), true, "Two arrays with the same item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy, arr2), true, "Two arrays with the same item should be equal.");
                var arr2copy2 = [entity1copy];
                assert.strictEqual(reflector.equalsEx(arr2, arr2copy2), true, "Two arrays with the equal item should be equal.");
                assert.strictEqual(reflector.equalsEx(arr2copy2, arr2), true, "Two arrays with the equal item should be equal.");
                var arr3 = [entity2];
                assert.strictEqual(reflector.equalsEx(arr1, arr3), false, "Two arrays with non-equal item should not be equal.");

                done();
            });
            
            test('shouldDisplayDescription method works', function (done) {
                var entity1 = reflector.newEntity(typeName1);
                var entity2 = reflector.newEntity(typeName2);
                
                assert.strictEqual(entity1.type().shouldDisplayDescription(), true, "shouldDisplayDescription for entity type TgPersistentEntityWithProperties should be true.");
                assert.strictEqual(entity2.type().shouldDisplayDescription(), false, "shouldDisplayDescription for entity type TgPersistentCompositeEntity should be false.");
                
                done();
            });
            
            test('empty union entity gives empty values for id, key and desc properties', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                union.key = 'bad key'; // should not really exist, but is provided for stronger checks
                union.desc = 'bad desc'; // should not really exist, but is provided for stronger checks
                union.id = 1; // should not really exist, but is provided for stronger checks
                
                union.propertyOne = null;
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), null);
                assert.strictEqual(union.get('desc'), null);
                assert.strictEqual(union.get('id'), null);
                
                done();
            });
            
            test('non-empty union entity gives values for id, key and desc properties from its active entity', function (done) {
                const union = reflector.newEntity('ua.com.fielden.platform.sample.domain.UnionEntity');
                union.key = 'bad key'; // should not really exist, but is provided for stronger checks
                union.desc = 'bad desc'; // should not really exist, but is provided for stronger checks
                union.id = 1; // should not really exist, but is provided for stronger checks
                
                const propertyOneVal = reflector.newEntity('ua.com.fielden.platform.sample.domain.EntityOne');
                propertyOneVal.key = 'EO1';
                propertyOneVal.desc = 'EO1 desc';
                propertyOneVal.id = 101;
                union.propertyOne = propertyOneVal;
                
                union.propertyTwo = null;
                
                assert.strictEqual(union.get('key'), 'EO1');
                assert.strictEqual(union.get('desc'), 'EO1 desc');
                assert.strictEqual(union.get('id'), 101);
                
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and trailing zeros should return 123.3000', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', 4, true), "123.3000");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', 4, true), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with scale and without trailing zeros should return 123.3', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', 4, false), "123.3");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return 123.3121', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', 4, false), "123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and trailing zeros should return $123.3000', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU', 4, true), "$123.3000");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with scale and trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU', 4, true), "$123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 money with scale and without trailing zeros should return $123.3', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU', 4, false), "$123.3");
                done();
            });
            
             test('foramtting: formatting 123.3121 decimal with scale and without trailing zeros should return $123.3121', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU', 4, false), "$123.3121");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU', undefined, true), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU', undefined, true), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 decimal with default scale and without trailing zeros should return 123.30', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3, 'en-AU'), "123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 decimal with default scale and without trailing zeros should return 123.31', function (done) {
                assert.equal(reflector.tg_formatDecimal(123.3121, 'en-AU'), "123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU', undefined, true), "$123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU', undefined, true), "$123.31");
                done();
            });
            
            test('foramtting: formatting 123.3 money with default scale and without trailing zeros should return $123.30', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3}, 'en-AU'), "$123.30");
                done();
            });
            
            test('foramtting: formatting 123.3121 money with default scale and without trailing zeros should return $123.31', function (done) {
                assert.equal(reflector.formatMoney({amount: 123.3121}, 'en-AU'), "$123.31");
                done();
            });
            
            test('prop retrieving: retrieveing of second level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const compositeEntity = reflector.newEntity(typeName2);
                compositeEntity.key1 = entity;
                compositeEntity.key2 = 7;
                const metaProp = reflector.getEntityTypeProp(compositeEntity, "key1.bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of first level property should work fine', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "bigDecimalProp");
                assert.equal(metaProp.precision(), 18);
                assert.equal(metaProp.scale(), 5);
                assert.equal(metaProp.trailingZeros(), true);
                done();
            });
            
            test('prop retrieving: retrieveing of empty property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
            
            test('prop retrieving: retrieveing of non exisiting property should return undefined', function (done) {
                const entity = reflector.newEntity(typeName1); 
                entity.key = 'DEMO01';
                const metaProp = reflector.getEntityTypeProp(entity, "nonExisting");
                assert.equal(typeof metaProp, 'undefined');
                done();
            });
        });
    </script>
</body>

</html>