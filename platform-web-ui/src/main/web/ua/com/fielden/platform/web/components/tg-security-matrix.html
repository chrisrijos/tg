<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/components/tree-table/tg-tree-table.html">
<link rel="import" href="/resources/components/tree-table/tg-tree-table-property-column.html">
<link rel='import' href='/resources/master/actions/tg-action.html'>
<link rel="import" href="/resources/master/tg-entity-master.html">
<link rel="import" href="/resources/master/tg-entity-master-behavior.html">
<link rel="import" href="/resources/reflection/tg-polymer-utils.html">

<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">

<link rel="import" href="/resources/polymer/paper-button/paper-button.html">

<dom-module id="tg-security-matrix">
    <template>
        <style>
            :host {
                height: 100%;
                width: 100%;
                @apply(--layout-vertical);
            }
            tg-entity-master {
                @apply(--layout-vertical);
            }
            .filter-panel::content > .filter-element {
                margin: 0 10px;
                @apply(--layout-flex);
            }
            .filter-panel {
                flex-shrink: 0;
            }
            .lock-layer {
                opacity: 0.5;
                display: none;
                background-color: white;
            }
            .lock-layer[lock] {
                display: initial;
            }
        </style>
        <tg-entity-master id="masterDom" entity-type="[[entityType]]" entity-id="new" _post-validated-default="[[_postValidatedDefault]]" _post-validated-default-error="[[_postValidatedDefaultError]]" _process-response="[[_processResponse]]" _process-error="[[_processError]]" _process-retriever-response="[[_processRetrieverResponse]]" _process-retriever-error="[[_processRetrieverError]]" _process-saver-response="[[_processSaverResponse]]" _process-saver-error="[[_processSaverError]]" _saver-loading="{{_saverLoading}}">
            <div style="width:100%;height:100%" class="relative layout vertical">
                <div class="layout horizontal filter-panel">
                    <content select=".filter-element"></content>
                </div>
                <tg-tree-table class="flex" id="securityMatrix" entities="[[entities]]">
                    <tg-test></tg-test>
                    <template is="dom-repeat" items="[[columns]]">
                        <tg-tree-table-property-column property="[[item.property]]" children-property="[[item.childrenProperty]]" parent-property="[[item.parentProperty]]" contains-checkbox="[[item.containsCheckbox]]" width="[[item.width]]" visible="[[item.visible]]" min-width="[[item.minWidth]]" grow-factor="[[item.growFactor]]" type="[[item.type]]" column-title="[[item.title]]" column-desc="[[item.desc]]" check="[[check]]"></tg-tree-table-property-column>
                    </template>
                </tg-tree-table>
                <div class="layout horizontal center-justified" style="padding:20px; flex-shrink:0;">
                    <tg-action id="cancelButton" enabled-states='[[_actions.REFRESH.enabledStates]]' short-desc='CANCEL' long-desc='Cancels all changes after save' current-state='EDIT' shortcut='ctrl+r meta+r' role='refresh' action='[[_resetSecurityMatrix]]' post-action='{{_postResetSecurityMatrix}}' post-action-error='{{_postResetSecurityMatrixError}}' style="margin:10px;"></tg-action>
                    <tg-action id="saveButton" enabled-states='[[_actions.SAVE.enabledStates]]' short-desc='SAVE' long-desc='Save changes' current-state='EDIT' shortcut='ctrl+s meta+s' action='[[_saveSecurityMatrix]]' post-action='{{_postSavedDefault}}' post-action-error='{{_postSavedDefaultError}}' style="margin:10px;"></tg-action>
                    <!-- save and cancel buttons goes here -->
                </div>
                <div class="lock-layer fit" lock$="[[lock]]"></div>
            </div>
        </tg-entity-master>
    </template>
    <script>
        (function () {
            'use strict'
            class SecurityMatrixEntity extends EntityStub {

                constructor(securityTokenEntity, userRoles, tokenRoleMap, parent) {
                    super(securityTokenEntity.get("key"));
                    this.title = securityTokenEntity.get("title");
                    this.desc = securityTokenEntity.get("desc");
                    if (parent) {
                        this.parent = parent;
                    }
                    this.children = [];
                    if (securityTokenEntity.children && securityTokenEntity.children.length > 0) {
                        this.children = securityTokenEntity.children.map(securityToken => new SecurityMatrixEntity(securityToken, userRoles, tokenRoleMap, this));
                    }
                    this.roleIdMap = {};
                    this.idRoleMap = {};
                    Object.values(userRoles).forEach(role => {
                        const roleKey = replaceWhitespacesWithUnderscore(role.get("key"));
                        this.roleIdMap[roleKey] = role.get("id");
                        this[roleKey] = false;
                        this.idRoleMap[role.get("id")] = roleKey;
                    });
                    const availTokenList = tokenRoleMap[securityTokenEntity.get("key")];
                    if (availTokenList) {
                        availTokenList.forEach(roleId => {
                            this[this.idRoleMap[roleId]] = true;
                        });
                    }
                    //Initiate 
                    this._tokenChecked = Object.keys(this.roleIdMap).some(role => this[role]) || (this.children && this.children.length > 0 && this.children.some(child => child._tokenChecked));
                    this._tokenRoleAssociationHandler = {};
                    this._newAssociations = [];
                    this._removedAssociations  = [];
                }

                set(property, value) {
                    const oldValue = this.get(property);
                    super.set(property, value);
                    if (Object.keys(this.roleIdMap).includes(property) && oldValue !== value) {
                        if (value) {
                            updateAssociations(this.roleIdMap[property], this._newAssociations, this._removedAssociations);
                        } else {
                            updateAssociations(this.roleIdMap[property], this._removedAssociations, this._newAssociations);
                        }
                    }
                    if (typeof this._tokenRoleAssociationHandler[property] === "function") {
                        this._tokenRoleAssociationHandler[property](value, this._getState(property));
                    }
                }
                
                getAssociationsToSave(objToSave) {
                    objToSave[this.get("id")] = this._newAssociations.slice();
                    if (this.children && this.children.length > 0) {
                        this.children.forEach(child => child.getAssociationsToSave(objToSave));
                    }
                }
                
                getAssociationsToRemove(objToSave) {
                    objToSave[this.get("id")] = this._removedAssociations.slice();
                    if (this.children && this.children.length > 0) {
                        this.children.forEach(child => child.getAssociationsToRemove(objToSave));
                    }
                }
                
                isChanged() {
                    return this._isChanged() || (this.children && this.children.length > 0 && this.children.some(child => child.isChanged()));
                }
                
                reset() {
                    if (this.children && this.children.length > 0) {
                        this.children.forEach(child => child.reset());
                    }
                    this._newAssociations.slice().forEach(associationId => {
                        this.set(this.idRoleMap[associationId], false);
                        this._checkColumnParent(this.idRoleMap[associationId]);
                    });
                    this._removedAssociations.slice().forEach(associationId => {
                        this.set(this.idRoleMap[associationId], true);
                        this._checkColumnParent(this.idRoleMap[associationId]);
                    });
                    this._checkRowParent();
                    this._checkColumnParent("_tokenChecked");
                }
                
                clearCurrentState() {
                    if (this.children && this.children.length > 0) {
                        this.children.forEach(child => child.clearCurrentState());
                    }
                    this._newAssociations = [];
                    this._removedAssociations = [];
                }
                
                _isChanged() {
                    return this._newAssociations.length > 0 || this._removedAssociations.length > 0;
                }

                _check(property, value) {
                    this._checkWithoutParent(property, value);
                    this._checkColumnParent(property);
                }

                _checkWithoutParent(property, value) {
                    if (this.children && this.children.length > 0) {
                        this.children.forEach(child => child._checkWithoutParent(property, value));
                    }
                    if (property === "_tokenChecked") {
                        Object.keys(this.roleIdMap).forEach(roleKey => {
                            this.set(roleKey, value);
                            this._checkColumnParent(roleKey);
                        });
                        this.set(property, value);
                    } else if (Object.keys(this.roleIdMap).includes(property)) {
                        this.set(property, value);
                        this._checkRowParent();
                    }
                }

                _checkRowParent() {
                    this.set("_tokenChecked", this._getState("_tokenChecked") !== "UNCHECKED");
                }

                _checkColumnParent(property) {
                    if (this.parent) {
                        const newState = this.parent._getState(property);
                        if (property === "_tokenChecked") {
                            this.parent.set(property, newState !== "UNCHECKED");
                        } else if (Object.keys(this.roleIdMap).includes(property)) {
                            this.parent.set(property, newState !== "UNCHECKED");
                            this.parent._checkRowParent();
                        }
                        this.parent._checkColumnParent(property);
                    }
                }

                _getState(property) {
                    if (this.children && this.children.length > 0) {
                        return calculateState(this.children.map(child => child._getState(property)));
                    } else {
                        if (property === "_tokenChecked") {
                            return calculateState(Object.keys(this.roleIdMap).map(roleKey => this._getState(roleKey)));
                        } else if (Object.keys(this.roleIdMap).includes(property)) {
                            return this.get(property) ? "CHECKED" : "UNCHECKED";
                        }
                    }
                }
            };
            const updateAssociations = function (value, newAssociations, removedAssociations) {
                const roleIndex = removedAssociations.indexOf(value);
                if (roleIndex >= 0) {
                    removedAssociations.splice(roleIndex, 1);
                } else {
                    newAssociations.push(value);
                }
            }
            const removeValueFrom = function (value, list) {
                const indexToRemove = list.indexOf(value);
                if (indexToRemove >= 0) {
                    list.splice(indexToRemove, 1);
                }
            };
            const calculateState = function (states) {
                if (states.every(state => state === "CHECKED")) {
                    return "CHECKED";
                } else if (states.every(state => state === "UNCHECKED")) {
                    return "UNCHECKED";
                }
                return "SEMICHECKED";
            };
            const replaceWhitespacesWithUnderscore = function (str) {
                return str.replace(/\s+/gi, "_");
            };
            Polymer({
                is: 'tg-security-matrix',

                behaviors: [Polymer.IronResizableBehavior, Polymer.TgBehaviors.TgEntityMasterBehavior],

                properties: {
                    entityType: String,

                    /**
                     * The entity that comes from insertion point and holds the information for schduling.
                     */
                    entity: {
                        type: Object,
                        observer: "_entityChanged"
                    },

                    hierarchyColumn: Object,

                    columns: Array,

                    entities: Array,
                    /**
                     * Need for locking schduling component during insertion point activation or refreshing.
                     */
                    lock: {
                        type: Boolean,
                        value: false
                    },

                    check: Function,
                    _resetSecurityMatrix: Function,
                    _postResetSecurityMatrix: Function,
                    _postResetSecurityMatrixError: Function,
                    _saveSecurityMatrix: Function,
                    _postSecurityMatrixSaved: Function
                },
                
                listeners: {
                    "tg-tree-state-changed": "_toggleButtonStates"
                },

                ready: function () {
                    //Configuring the security matrix master
                    this.entityType = "ua.com.fielden.platform.entity.SecurityMatrixSaveAction"
                    this.check = function (entity, property, value) {
                        entity._check(property, value);
                    };
                    this._resetSecurityMatrix = function () {
                        this.entities.forEach(entity => entity.reset());
                        this.$.cancelButton.postAction();
                    }.bind(this);
                    this._postResetSecurityMatrix = function () {};
                    this._postResetSecurityMatrixError = function () {};
                    this._saveSecurityMatrix = function () {
                        const associationsToSave = {};
                        const associationsToRemove = {};
                        this.entities.forEach(entity => entity.getAssociationsToSave(associationsToSave));
                        this.entities.forEach(entity => entity.getAssociationsToRemove(associationsToRemove));
                        this._currBindingEntity['associationsToSave'] = associationsToSave;
                        this._currBindingEntity['associationsToRemove'] = associationsToRemove;
                        this.save();
                    }.bind(this);
                    this.postSaved = function () {
                        this.entities.forEach(entity => entity.clearCurrentState());
                        this._toggleButtonStates();
                    }.bind(this);
                    this._toggleButtonStates = function () {
                        const changed = this.entities.some(entity => entity.isChanged());
                        this.$.saveButton.outerEnabled = changed;
                        this.$.cancelButton.outerEnabled = changed;
                    }.bind(this);
                },

                attached: function () {
                    this.async(function () {
                        if (!this._currBindingEntity) {
                            this.retrieve();
                        }
                    });
                },
                
                filterTokens: function (text) {
                    this.$.securityMatrix.filterTokens(text);
                },
                
                filterRoles: function (text) {
                    this.$.securityMatrix.filterRoles(text);
                },
                
                _isNecessaryForConversion: function (propertyName) {
                    return ['associationsToSave', 'associationsToRemove'].includes(propertyName);
                },

                _entityChanged: function (newBindingEntity, oldOne) {
                    const newEntity = newBindingEntity ? newBindingEntity['@@origin'] : null;
                    if (newEntity) {
                        const columnList = [];
                        columnList.push({
                            title: "Security Tokens",
                            desc: "Security Tokens Hierarchy",
                            property: "title",
                            childrenProperty: "children",
                            parentProperty: "parent",
                            containsCheckbox: true,
                            width: 200,
                            growFactor: 2,
                            minWidth: 200,
                            type: "String",
                            visible: true,
                            check: this.check,
                        });
                        newEntity.get("userRoles").forEach(role => {
                            columnList.push({
                                title: role.get("key"),
                                desc: role.get("desc"),
                                property: replaceWhitespacesWithUnderscore(role.get("key")),
                                width: 30,
                                growFactor: 0,
                                minWidth: 50,
                                type: "Boolean",
                                visible: true,
                                check: this.check,
                            });
                        });
                        this.columns = columnList;
                        this.entities = newEntity.get("tokens").map(token => new SecurityMatrixEntity(token, newEntity.get("userRoles"), newEntity.get("tokenRoleMap")));
                        this._toggleButtonStates();
                    }
                },

                _masterDom: function () {
                    return this.$.masterDom;
                },

                /**
                 * The core-ajax component for entity retrieval.
                 */
                _ajaxRetriever: function () {
                    return this._masterDom()._ajaxRetriever();
                },

                /**
                 * The core-ajax component for entity saving.
                 */
                _ajaxSaver: function () {
                    return this._masterDom()._ajaxSaver();
                },

                /**
                 * The validator component.
                 */
                _validator: function () {
                    return this._masterDom()._validator();
                },

                /**
                 * The component for entity serialisation.
                 */
                _serialiser: function () {
                    return this._masterDom()._serialiser();
                },

                /**
                 * The reflector component.
                 */
                _reflector: function () {
                    return this._masterDom()._reflector();
                },

                /**
                 * The toast component.
                 */
                _toastGreeting: function () {
                    return this._masterDom()._toastGreeting();
                }

            });
        })();
    </script>
</dom-module>