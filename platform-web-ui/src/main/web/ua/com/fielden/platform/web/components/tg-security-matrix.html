<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/components/tree-table/tg-tree-table.html">
<link rel="import" href="/resources/components/tree-table/tg-tree-table-property-column.html">
<link rel='import' href='/resources/master/actions/tg-action.html'>
<link rel="import" href="/resources/master/tg-entity-master.html">
<link rel="import" href="/resources/master/tg-entity-master-behavior.html">
<link rel="import" href="/resources/reflection/tg-polymer-utils.html">

<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">


<dom-module id="tg-security-matrix">
    <template>
        <style>
            :host {
                height: 100%;
                width: 100%;
                @apply(--layout-vertical);

            }
            .lock-layer {
                opacity: 0.5;
                display: none;
                background-color: white;
            }
            .lock-layer[lock] {
                display: initial;
            }
        </style>
        <tg-entity-master id="masterDom" entity-type="[[entityType]]" entity-id="new" _post-validated-default="[[_postValidatedDefault]]" _post-validated-default-error="[[_postValidatedDefaultError]]" _process-response="[[_processResponse]]" _process-error="[[_processError]]" _process-retriever-response="[[_processRetrieverResponse]]" _process-retriever-error="[[_processRetrieverError]]" _process-saver-response="[[_processSaverResponse]]" _process-saver-error="[[_processSaverError]]" _saver-loading="{{_saverLoading}}">
            <div style="width:100%;height:100%" class="relative layout vertical">
                <div>
                    <!-- filtering editors goes here -->
                </div>
                <tg-tree-table class="flex" id="securityMatrix" entities="[[entities]]">
                    <tg-test></tg-test>
                    <template is="dom-repeat" items="[[columns]]">
                        <tg-tree-table-property-column property="[[item.property]]" children-property="[[item.childrenProperty]]" parent-property="[[item.parentProperty]]" contains-checkbox="[[item.containsCheckbox]]" width="[[item.width]]" min-width="[[item.minWidth]]" grow-factor="[[item.growFactor]]" type="[[item.type]]" column-title="[[item.title]]" column-desc="[[item.desc]]" check="[[check]]"></tg-tree-table-property-column>
                    </template>
                </tg-tree-table>
                <div class="layout horizontal center-justified" style="padding:20px;">
                    <tg-action enabled-states='[[_actions.REFRESH.enabledStates]]' short-desc='[[_actions.REFRESH.shortDesc]]' long-desc='[[_actions.REFRESH.longDesc]]' current-state='[[currentState]]' shortcut='ctrl+r meta+r' role='refresh' action='[[_actions.REFRESH.action]]' post-action='{{_postRetrievedDefault}}' post-action-error='{{_postRetrievedDefaultError}}' style="margin:10px;"></tg-action>
                    <tg-action enabled-states='[[_actions.SAVE.enabledStates]]' short-desc='[[_actions.SAVE.shortDesc]]' long-desc='[[_actions.SAVE.longDesc]]' current-state='[[currentState]]' shortcut='ctrl+s meta+s' action='[[_actions.SAVE.action]]' post-action='{{_postSavedDefault}}' post-action-error='{{_postSavedDefaultError}}' style="margin:10px;"></tg-action>
                    <!-- save and cancel buttons goes here -->
                </div>
                <div class="lock-layer fit" lock$="[[lock]]"></div>
            </div>
        </tg-entity-master>
    </template>
    <script>
        (function () {
            'use strict'
            class SecurityMatrixEntity extends EntityStub {

                constructor(securityTokenEntity, userRoles, tokenRoleMap, parent) {
                    super(securityTokenEntity.get("key"));
                    this.title = securityTokenEntity.get("title");
                    if (parent) {
                        this.parent = parent;
                    }
                    this.children = [];
                    if (securityTokenEntity.children && securityTokenEntity.children.length > 0) {
                        this.children = securityTokenEntity.children.map(securityToken => new SecurityMatrixEntity(securityToken, userRoles, tokenRoleMap, this));
                    }
                    this.roleIdMap = {};
                    this.idRoleMap = {};
                    Object.values(userRoles).forEach(role => {
                        const roleKey = replaceWhitespacesWithUnderscore(role.get("key"));
                        this.roleIdMap[roleKey] = role.get("id");
                        this[roleKey] = false;
                        this.idRoleMap[role.get("id")] = roleKey;
                    });
                    tokenRoleMap[securityTokenEntity.get("key")].forEach(roleId => {
                        this[this.idRoleMap[roleId]] = true;
                    });
                    //Initiate 
                    if (this.children && this.children.length > 0) {
                        this._tokenChecked = this.children.every(child => child._tokenChecked);
                    } else {
                        this._tokenChecked = Object.keys(this.roleIdMap).every(role => this[role]);
                    }
                    this._tokenRoleAssociationHandler = {};
                    this._newAssociations = [];
                    this._removedAssociations = [];
                }

                set(property, value) {
                    const oldValue = this.get(property);
                    super.set(property, value);
                    if (typeof this._tokenRoleAssociationHandler[property] === "function") {
                        this._tokenRoleAssociationHandler[property](value, this._getState(property));
                    }
                    if (Object.keys(this.roleIdMap).includes(property) && oldValue !== value) {
                        if (value) {
                            updateAssociations(this.roleIdMap[property], this._newAssociations, this._removedAssociations);
                        } else {
                            updateAssociations(this.roleIdMap[property], this._removedAssociations, this._newAssociations);
                        }
                    }
                }

                _check(property, value) {
                    this._checkWithoutParent(property, value);
                    this._checkColumnParent(property);
                }

                _checkWithoutParent(property, value) {
                    if (this.children && this.children.length > 0) {
                        this.children.forEach(child => child._checkWithoutParent(property, value));
                    }
                    if (property === "_tokenChecked") {
                        Object.keys(this.roleIdMap).forEach(roleKey => {
                            this.set(roleKey, value);
                            this._checkColumnParent(roleKey);
                        });
                        this.set(property, value);
                    } else if (Object.keys(this.roleIdMap).includes(property)){
                        this.set(property, value);
                        this._checkRowParent();
                    }
                }
                
                _checkRowParent() {
                    this.set("_tokenChecked", this._getState("_tokenChecked") !== "UNCHECKED");
                }

                _checkColumnParent(property) {
                    if (this.parent) {
                        const newState = this.parent._getState(property);
                        if (property === "_tokenChecked") {
                            this.parent.set(property, newState !== "UNCHECKED");
                        } else if (Object.keys(this.roleIdMap).includes(property)) {
                            this.parent.set(property, newState !== "UNCHECKED");
                            this.parent._checkRowParent();
                        }
                        this.parent._checkColumnParent(property);
                    }
                }

                _getState(property) {
                    if (this.children && this.children.length > 0) {
                        return calculateState(this.children.map(child => child._getState(property)));
                    } else {
                        if (property === "_tokenChecked") {
                            return calculateState(Object.keys(this.roleIdMap).map(roleKey => this._getState(roleKey)));
                        } else if (Object.keys(this.roleIdMap).includes(property)) {
                            return this.get(property) ? "CHECKED" : "UNCHECKED";
                        }
                    }
                }


            };
            const updateAssociations = function (value, newAssociations, removedAssociations) {
                const roleIndex = removedAssociations.indexOf(value);
                if (roleIndex >= 0) {
                    removedAssociations.splice(roleIndex, 1);
                } else {
                    newAssociations.push(value);
                }
            }
            const removeValueFrom = function (value, list) {
                const indexToRemove = list.indexOf(value);
                if (indexToRemove >= 0) {
                    list.splice(indexToRemove, 1);
                }
            };
            const calculateState = function (states) {
                if (states.every(state => state === "CHECKED")) {
                    return "CHECKED";
                } else if (states.every(state => state === "UNCHECKED")) {
                    return "UNCHECKED";
                }
                return "SEMICHECKED";
            };
            const replaceWhitespacesWithUnderscore = function (str) {
                return str.replace(/\s+/gi, "_");
            };
            Polymer({
                is: 'tg-security-matrix',

                behaviors: [Polymer.IronResizableBehavior, Polymer.TgBehaviors.TgEntityMasterBehavior],

                properties: {
                    entityType: String,

                    /**
                     * The entity that comes from insertion point and holds the information for schduling.
                     */
                    entity: {
                        type: Object,
                        observer: "_entityChanged"
                    },

                    hierarchyColumn: Object,

                    columns: Array,

                    entities: Array,
                    /**
                     * Need for locking schduling component during insertion point activation or refreshing.
                     */
                    lock: {
                        type: Boolean,
                        value: false
                    },
                    
                    check: Function,
                    isChecked: Function
                },

                ready: function () {
                    //Configuring the security matrix master
                    this.entityType = "ua.com.fielden.platform.entity.SecurityMatrixSaveAction"
                    this.check = function(entity, property, value) {
                        entity._check(property, value);
                    };
                    this.isChecked = function(entity, property) {
                        return entity._isChecked(property);
                    }
                },

                attached: function () {
                    this.async(function () {
                        if (!this._currBindingEntity) {
                            this.retrieve();
                        }
                    });
                },

                _entityChanged: function (newBindingEntity, oldOne) {
                    const newEntity = newBindingEntity ? newBindingEntity['@@origin'] : null;
                    if (newEntity) {
                        const columnList = [];
                        columnList.push({
                            title: "Security Tokens",
                            desc: "Security Tokens Hierarchy",
                            property: "title",
                            childrenProperty: "children",
                            parentProperty: "parent",
                            containsCheckbox: true,
                            width: 200,
                            growFactor: 2,
                            minWidth: 200,
                            type: "String",
                            check: this.check,
                            isChecked: this.isChecked
                        });
                        newEntity.get("userRoles").forEach(role => {
                            columnList.push({
                                title: role.get("key"),
                                desc: role.get("desc"),
                                property: replaceWhitespacesWithUnderscore(role.get("key")),
                                width: 30,
                                growFactor: 0,
                                minWidth: 50,
                                type: "Boolean",
                                check: this.check,
                                isChecked: this.isChecked
                            });
                        });
                        this.columns = columnList;
                        this.entities = newEntity.get("tokens").map(token => new SecurityMatrixEntity(token, newEntity.get("userRoles"), newEntity.get("tokenRoleMap")));
                        console.log(newEntity);
                    }
                },

                _masterDom: function () {
                    return this.$.masterDom;
                },

                /**
                 * The core-ajax component for entity retrieval.
                 */
                _ajaxRetriever: function () {
                    return this._masterDom()._ajaxRetriever();
                },

                /**
                 * The core-ajax component for entity saving.
                 */
                _ajaxSaver: function () {
                    return this._masterDom()._ajaxSaver();
                },

                /**
                 * The validator component.
                 */
                _validator: function () {
                    return this._masterDom()._validator();
                },

                /**
                 * The component for entity serialisation.
                 */
                _serialiser: function () {
                    return this._masterDom()._serialiser();
                },

                /**
                 * The reflector component.
                 */
                _reflector: function () {
                    return this._masterDom()._reflector();
                },

                /**
                 * The toast component.
                 */
                _toastGreeting: function () {
                    return this._masterDom()._toastGreeting();
                }

            });
        })();
    </script>
</dom-module>