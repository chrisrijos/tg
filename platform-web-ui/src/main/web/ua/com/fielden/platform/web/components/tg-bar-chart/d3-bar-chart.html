<link rel="import" href="/resources/components/d3-lib.html">

<script>
    (function () {
        //Merges two objects up to two 
        const merge2LevelData = function (oldOptions, newOptions) {
            const newObj = mergeData(oldOptions, newOptions);
            Object.keys(newObj).filter(key => typeof newObj[key] === 'object').forEach(key => {
                newObj[key] = mergeData(oldOptions[key], newOptions[key]);
            });
            return newObj;
        };
        const mergeData = function (oldData, newData) {
            return Object.assign({}, oldData, newData)
        };
        
        /**
         * Gets or sets the value for entity if value is undefined the it gets the value ortherwise it sets the value. Also obj might be a function it means that user has provided formatter for value.
         */
        const value = (obj, data, value) => {
            if (typeof obj === 'function') {
                return obj(data, value);
            } else {
                if (typeof value === 'undefined') {
                    return data.get(obj.toString());
                } else {
                    const lastDotIndex = obj.lastIndexOf(".");
                    const rest = lastDotIndex > -1 ? obj.slice(lastDotIndex + 1) : obj;
                    const firstVal = lastDotIndex > -1 ? data.get(obj.slice(0, lastDotIndex)) : data;
                    if (firstVal && rest) {
                        firstVal.set(rest, value);
                    }
                }
            }
        };
        
        /**
         * Fires the select event for provided entity and select parameter.
         */
        const fireSelectEvent = (entity, select, chartArea) => {
            const event = new CustomEvent("bar-entity-selected", {
                detail: {
                    shouldScrollToSelected: true,
                    entities: [{
                        entity: entity,
                        select: select
                    }]
                },
                bubbles: true,
                cancelable: true
            });
            chartArea.dispatchEvent(event);
        };
        
        
        
        
        const marker = (selection, dataOptions, x, y, h, unscalableNodes, markerGenerator, draw) => {
            const markerSelection = selection.attr("transform", d => "translate(" + (x(d[dataOptions.groupPropName]) + x.bandwidth() / 2) + ", " + (y(d[dataOptions.valuePropName]) - 10) + ")");
            if (draw) {
                selection.each(function (d) {
                    let rect = d3.select(this).append("rect").attr("class", "mark-rect");
                    let text = d3.select(this).append("text").attr("class", "mark-text").style("text-anchor", "middle").text(markerGenerator(d))
                    upadateMarkerSize(rect, text);
                }).each(function () {
                    unscalableNodes.push(this);
                });
            } else {
                selection.each(function (d) {
                    upadateMarkerSize(d3.select(this).select(".mark-rect"), d3.select(this).select(".mark-text"));
                });
            }
        };
        
        
        
        
        
        
        class BarChart {
            
            constructor (container, options, data) {
                //////////////////////Private variables can be configured through the api//////////////////////////
                //Most common configuration properties.
                this._options = {
                    width: 110,
                    height: 80,
                    margin: {
                        top: 35,
                        right: 35,
                        bottom: 45,
                        left: 75
                    },
                    label: "",
                    xAxis: {
                        label: ""
                    },
                    yAxis: {
                        label: "",
                        ticks: 10
                    },
                    dataPropertyNames: {
                        id: "id",
                        groupKeyProp: "groupKeyProp",
                        groupDescProp: "groupDescProp",
                        valueProp: "valueProp",
                    },
                    barColour: "#0288D1",
                    selectedColour: "white",
                    tooltip: d => "<b>" + value("groupKeyProp", d) + "</b>(<i>" + value("groupDescProp", d) + "</i>)",
                    click: d => {},
                };
                this._options = options ? merge2LevelData(this._options, options) : this._options;
                this._data = [];
                this._data = data ? data : this._data;

                //////////////////////Functional private variables///////////////////
                this._actualWidth = this._options.width - this._options.margin.left - this._options.margin.right;
                this._actualHeight = this._options.height - this._options.margin.bottom - this._options.margin.top;
                //This is needed to hold entiteis those were selected
                this._selectedEntities = [];
                //Field needed to track the selectd bars.
                this._selectedBars = [];
                //Holds the current transform 
                this._currentTransform = d3.zoomIdentity;
                // Holds the list of elements those can't be scaled and is used after current transforamation changed to unscale these elements.
                this._elemToUnscale = [];

                //Creating coordinate system.
                this._xs = this._xScale();
                this._ys = this._yScale();
                // Createing x and y axis they also should be modifiable.
                this._xAxis = this._createXAxis();
                this._yAxis = this._createYAxis();
                // Creating grid that should be modifiable
                this._yGrid = this._createYGrid();
                //create clip path to cut off the chart area.
                this._clipPath = this._createClipPath(container);
                //Create area for zooming and panning that will contain axes, grids and chart area with bars.
                this._chartArea = this._createChartArea(container);
                //Create background area
                this._background = this._createBackground();

                //Draw grid
                this._yGridGroup = this._drawYGrid();

                //Creating bar container.
                this._barContainer = this._createBarContainer();

                //Draw axes
                this._xAxisGroup = this._drawXAxes();
                this._yAxisGroup = this._drawYAxes();

                //Draw labels
                this._chartLabel = this._drawChartLabel(container);
                this._xAxisLabel = this._drawXAxisLabel(container);
                this._yAxisLabel = this._drawYAxisLabel(container);

                //Now draw job bars
                this._drawBars();
                //Draw markers after bars
                this._drawBarLabels();
                //Creating zoom&pan behaviour.
                this._zoom = d3.zoom()
                    .scaleExtent([1, 10])
                    .translateExtent([[0, 0], [0, this._actualHeight]])
                    .extent([[0, 0], [0, this._actualHeight]])
                    .on("zoom", () => {
                        this._currentTransform = d3.event.transform;
                        this._yAxisGroup.call(this._yAxis.scale(this._currentTransform.rescaleY(this._ys)));
                        this._yGridGroup.call(this._yGrid.scale(this._currentTransform.rescaleY(this._ys)));
                        this._barContainer.attr("transform", "translate(0, " + this._currentTransform.y + ")scale(1, " + this._currentTransform.k + ")");
                        this._unscale();
                    });
                this._chartArea.call(this._zoom).on("dblclick.zoom", null);
            }
            
            repaint(resetState) {
                 //The old position of origin point.Needed to update the position of viewpoint after resizing.
                let oldY = this._yAxis.scale().invert(0);
                //Calculate new width and height without margins.
                this._actualWidth = this._options.width - this._options.margin.left - this._options.margin.right;
                this._actualHeight = this._options.height - this._options.margin.bottom - this._options.margin.top;
                if (this._actualWidth < 0) {
                    this._options.width = this._options.margin.left + this._options.margin.right
                    this._actualWidth = 0;
                }
                if (this._actualHeight < 0) {
                    this._options.height = this._options.margin.bottom + this._options.margin.top;
                    this._actualHeight = 0;
                }

                // Reset visualy selected and activated bars.
                if (resetState) {
                    this._selectedBars = [];
                }
                // Create new scales acoording to new width and height.
                this._xs = this._xScale();
                this._ys = this._yScale();
                // Update clip path according to new width and height.
                this._clipPath.attr("width", this._actualWidth).attr("height", this._actualHeight);
                // Update chart group node according to new margins. 
                this._chartArea.attr("transform", "translate(" + this._options.margin.left + "," + this._options.margin.top + ")");
                // Update background rectangle according to new width and height
                this._background.attr("width", this._actualWidth).attr("height", this._actualHeight);
                this._yGridGroup.call(this._yGrid.tickSize(-this._actualWidth).scale(this._ys)).call(this._yGrid.scale(this._currentTransform.rescaleY(this._ys)));
                this._xAxisGroup.attr("transform", "translate(0," + this._actualHeight + ")").call(this._xAxis.scale(this._xs));
                this._yAxisGroup.call(this._yAxis.scale(this._ys)).call(this._yAxis.scale(this._currentTransform.rescaleY(this._ys)));
                // Update chart and axis captioins
                this._chartLabel.call(this._setChartLabelData.bind(this));
                this._xAxisLabel.call(this._setXAxisLabelData.bind(this));
                this._yAxisLabel.call(this._setYAxisLabelData.bind(this));
                // Update bars.
                this._drawBars();
                //update markers after bars
                this._drawBarLabels();
                //Update zoom behavior 
                this._zoom.translateExtent([[0, 0], [0, this._actualHeight]])
                    .extent([[0, 0], [0, this._actualHeight]]);
                //Unscale nodes
                this._unscale();
                
                //Update the container translation in order to remain current translate position when window size was changed
                let newH = this._yAxis.scale()(oldY);
                if (resetState) {
                    this._chartArea.call(this._zoom.transform, d3.zoomIdentity);
                } else if (newH) {
                    this._chartArea.call(this._zoom.translateBy, 0, (0 - newH) / this._currentTransform.k);
                }
            }
            
            set options(val) {
                this._options = val ? merge2LevelData(this._options, val) : this._options;
                this.repaint();
            }

            get options() {
                return this._options;
            }

            set data(data) {
                this._data = data || this._data;
                this.repaint(true);
            }

            get data() {
                return this._data;
            }

            selectEntity(entity, select) {
                this._selectEntity(this._barContainer.select("#bar_" + value(this._options.dataPropertyNames.id, entity)).node(), 
                                   this._barContainer.select("#marker_" + value(this._options.dataPropertyNames.id, entity)).node(),
                                   entity, select);
            }
            
            _xDomain() {
                return this._data.map(d => value(this._options.dataPropertyNames.groupKeyProp, d));
            }
            _yDomain() {
                let maxRange = d3.max(this._data, d => value(this._options.dataPropertyNames.valueProp, d));
                return [0, maxRange ? maxRange + (0.1 + Math.abs(0.3 - 0.0001 * this._actualHeight)) * maxRange : 0];
            }
            _xScale() {
                return d3.scaleBand()
                    .rangeRound([0, this._actualWidth])
                    .padding(0.1) // could be configurable 
                    .domain(this._xDomain());
            }
            _yScale() {
                return d3.scaleLinear()
                    .range([this._actualHeight, 0])
                    .domain(this._yDomain())
            }
            
            _createXAxis() {
                return d3.axisBottom(this._xs);
            }
            
            _createYAxis() {
                return d3.axisLeft(this._ys).ticks(this._options.yAxis.ticks);
            }
            
            _createYGrid() {
                return this._createYAxis().tickSize(-this._actualWidth).tickFormat("").tickSizeOuter(0);
            }
            
            _createClipPath(container) {
                return d3.select(container).append('defs').append("clipPath").attr("id", "bar-" + this._options.dataPropertyNames.valueProp + "-clip")
                    .append("rect").attr("width", this._actualWidth).attr("height", this._actualHeight);
            }

            _createChartArea(container) {
                return d3.select(container).append("g")
                    .attr("class", "chart-area")
                    .attr("transform", "translate(" + this._options.margin.left + "," + this._options.margin.top + ")");
            }

            _createBackground() {
                return this._chartArea.append("rect").attr("class", "chart-background").attr("width", this._actualWidth).attr("height", this._actualHeight);
            }
            
            _drawYGrid() {
                console.log(this._yGrid.scale().domain);
                return this._chartArea.append("g").attr("class", "grid y-grid").call(this._yGrid);
            }
            
            _createBarContainer() {
                return this._chartArea.append("g").attr("clip-path", "url(#bar-" + this._options.dataPropertyNames.valueProp + "-clip)").append("g").attr("class", "bar-container");
            }
            
            _drawXAxes() {
                return this._chartArea.append("g").attr("class", "axis x-axis")
                    .attr("transform", "translate(0," + this._actualHeight + ")").call(this._xAxis);
            }

            _drawYAxes() {
                return this._chartArea.append("g").attr("class", "axis y-axis").call(this._yAxis);
            }
            
            _setChartLabelData(chartLabel) {
                chartLabel.text(this._options.label)
                    .attr("x", this._options.margin.left + this._actualWidth / 2)
                    .attr("y", this._options.margin.top - 10);
            }

            _drawChartLabel(container) {
                return d3.select(container)
                    .append("text")
                    .attr("class", "chart-label")
                    .style("text-anchor", "middle")
                    .style("alignment-baseline", "baseline")
                    .call(this._setChartLabelData.bind(this));
            }

            _setXAxisLabelPosition(xAxisLabel) {
                const axisBox = this._xAxisGroup.node().getBBox();
                if (axisBox.width !== 0 && axisBox.height !== 0) {
                    xAxisLabel
                        .attr("x", this._options.margin.left + this._actualWidth / 2)
                        .attr("y", this._actualHeight + this._options.margin.top + axisBox.height + 10);
                } else if (this._actualWidth !== 0 && this._actualHeight !== 0) {
                    setTimeout(() => this._setXAxisLabelPosition(xAxisLabel), 100);
                }
            }

            _setXAxisLabelData(xAxisLabel) {
                xAxisLabel.text(this._options.xAxis.label).call(this._setXAxisLabelPosition.bind(this));
            }

            _drawXAxisLabel(container) {
                return d3.select(container)
                    .append("text")
                    .attr("class", "x-axis-label")
                    .style("text-anchor", "middle")
                    .style("alignment-baseline", "hanging")
                    .call(this._setXAxisLabelData.bind(this));
            }

            _setYAxisLabelPosition(yAxisLabel) {
                const axisBox = this._yAxisGroup.node().getBBox();
                if (axisBox.width !== 0 && axisBox.height !== 0) {
                    yAxisLabel
                        .attr("x", -this._options.margin.top - this._actualHeight / 2)
                        .attr("y", this._options.margin.left - axisBox.width - 10);
                } else if (this._actualWidth !== 0 && this._actualHeight !== 0) {
                    setTimeout(() => this._setYAxisLabelPosition(yAxisLabel), 100);
                }
            }

            _setYAxisLabelData(yAxisLabel) {
                yAxisLabel.text(this._options.yAxis.label).call(this._setYAxisLabelPosition.bind(this));
            }

            _drawYAxisLabel(container) {
                return d3.select(container)
                    .append("text")
                    .attr("class", "y-axis-label")
                    .style("text-anchor", "middle")
                    .style("alignment-baseline", "baseline")
                    .call(this._setYAxisLabelData.bind(this))
                    .attr("transform", "rotate(-90)");
            }
            
            _drawBars() {
                const self = this;
                const updateSelection = self._barContainer.selectAll(".bar").data(this._data);
                const insertSelection = updateSelection.enter();
                const removeSelection = updateSelection.exit();

                //update bars
                updateSelection.call(self._updateBar.bind(self));
                //insert bars
                insertSelection.call(self._insertNewBar.bind(self));
                //removed unnedded tasks
                removeSelection.remove();
            }
            
            _insertNewBar(selection) {
                const self = this;
                const newBars = selection.append("rect").attr("class", "bar").on("click", function (d) {
                        if (d3.event.button == 0 && (d3.event.ctrlKey || d3.event.metaKey)) {
                            self._selectEntity(this, d, !self._isEntitySelected(d), true);
                        } else {
                            self._options.click(d);
                        }
                    })
                    .call(self._updateBar.bind(self));
            }
            
            _updateBar(selection) {
                selection.attr("id", d => "bar_" + value(this._options.dataPropertyNames.id, d));
                
                selection.style("fill", d => this._isEntitySelected(d) ? this._options.selectedColor : this._options.barColour)
                    .attr("x", d => this._xs(value(this._options.dataPropertyNames.groupKeyProp, d)))
                    .attr("y", d => this._ys(value(this._options.dataPropertyNames.valueProp, d)))
                    .attr("height", d => this._actualHeight - this._ys(value(this._options.dataPropertyNames.valueProp, d)))
                    .attr("width", this._xs.bandwidth());
                    //TODO add tooltips 
                    //.attr("tooltip-text", this._options.tooltip);
            }
            
            _drawBarLabels() {
                const self = this;
                const updateSelection = self._barContainer.selectAll(".marker").data(this._data);
                const insertSelection = updateSelection.enter();
                const removeSelection = updateSelection.exit();

                //update markers
                updateSelection.call(self._updateMarker.bind(self));
                //insert new markers
                insertSelection.call(self._insertNewMarker.bind(self));
                //remove markers
                removeSelection.remove();
            }
            
            _insertNewMarker(selection) {
                const self = this;
                const markerGroup = selection.append("g")
                    .attr("id", d => "marker_" + value(this._options.dataPropertyNames.id, d))
                    .attr("class", "marker")
                    .each(function () {
                        self._elemToUnscale.push(this);
                    });
                markerGroup.append("rect").attr("class", "mark-rect");
                markerGroup.append("text").attr("class", "mark-text").style("text-anchor", "middle")
                markerGroup.call(this._updateMarker.bind(this));
            }
            
            _updateMarker(selection) {
                const self = this; 
                selection.attr("transform", d => "translate(" 
                    + (this._xs(value(this._options.dataPropertyNames.groupKeyProp, d)) + this._xs.bandwidth() / 2) 
                    + ", " + (this._ys(value(this._options.dataPropertyNames.valueProp, d)) - 10) + ")")
                    .style("fill", d => this._isEntitySelected(d) ? this._options.selectedColor(d) : null);
                selection.each(function (d) {
                    let rect = d3.select(this).select(".mark-rect");
                    let text = d3.select(this).select(".mark-text").text(value(self._options.dataPropertyNames.valueProp, d));
                    self._updateMarkerPosition(rect, text);
                });
            }
            
            _updateMarkerPosition(rect, text) {
                let textBox = text.node().getBBox();
                if (textBox.width !== 0 && textBox.height !== 0) {
                    rect.attr("x", textBox.x - 5).attr("y", textBox.y - 1).attr("width", textBox.width + 10).attr("height", textBox.height + 2);
                } else {
                    setTimeout(() => this._updateMarkerPosition(rect, text), 100);
                }
            }
            
            _isEntitySelected(entity) {
                return !!this._selectedEntities.find(selectedEntity => value(this._options.dataPropertyNames.id, selectedEntity) === value(this._options.dataPropertyNames.id, entity));
            }
            
            _selectEntity(bar, marker, entity, select, fireEvent) {
                if (entity) {
                    const entityIndex = this._selectedEntities.findIndex(selectedEntity => value(this._options.dataPropertyNames.id, selectedEntity) === value(this._options.dataPropertyNames.id, entity));
                    if (select) {
                        // add entity to selected if it is not there yet
                        if (entityIndex < 0) {
                            this._selectedEntities.push(entity);
                            if (fireEvent) {
                                fireSelectEvent(entity, select, this._chartArea.node());
                            }
                        }
                    } else {
                        // remove entity from selected if it is there
                        if (entityIndex >= 0) {
                            this._selectedEntities.splice(entityIndex, 1);
                            if (fireEvent) {
                                fireSelectEvent(entity, select, this._chartArea.node());
                            }
                        }
                    }
                    if (bar && marker) {
                        this._selectBar(bar, marker, entity, select);
                    }
                }
            }
            
            _selectBar(bar, marker, entity, select) {
                const indexOfBar = this._selectedBars.indexOf(bar);
                d3.select(bar).d3Bar.style("fill", select ? this._options.selectedColor(entity) : value(this._options.dataPropertyNames.color, entity));
                d3.select(marker).d3Bar.style("fill", select ? this._options.selectedColor(entity) : null);
                
                if (select) {
                    if (indexOfBar < 0) {
                        this._selectedBars.push(bar);
                    }
                } else {
                    if (indexOfBar >= 0) {
                        this._selectedBars.splice(indexOfBar, 1);
                    }
                }
            }
            
            _unscale() {
                const elementsToRemove = [];
                this._elemToUnscale.forEach(el => {
                    const elementToRemove = this._unscaleElement(el);
                    if (elementToRemove) {
                        elementsToRemove.push(el);
                    }
                });
                elementsToRemove.forEach(el => {
                    const elIndex = this._elemToUnscale.indexOf(el);
                    if (elIndex >= 0) {
                        this._elemToUnscale.splice(elIndex, 1);
                    }
                });
            }
            
            _unscaleElement(el) {
                if (el.parentElement) {
                    let xf;
                    if (el.transform.baseVal.length < 2) {
                        // Keep a single transform matrix in the stack for fighting transformations
                        // Be sure to apply this transformation after existing transformations (translate)
                        xf = this._chartArea.node().ownerSVGElement.createSVGTransform();
                        el.transform.baseVal.appendItem(xf);
                    } else {
                        xf = el.transform.baseVal[1];
                    }
                    let m = this._chartArea.node().getTransformToElement(el.parentNode);
                    m.e = 0; // Ignore (preserve) any translations done up to this point
                    m.f = 10 * (1 - m.d);
                    xf.setMatrix(m);
                } else {
                    return el;
                }
            }
        }

        d3.barChart = (container, options, data) => {
            const barChart = new BarChart(container, options, data);

            const chart = {
                _chartForDebugging: barChart,
                options: o => {
                    if (o) {
                        barChart.options = o;
                        return chart;
                    } else {
                        return barChart.options;
                    }
                },
                data: d => {
                    if (d) {
                        barChart.data = d;
                        return chart;
                    } else {
                        return barChart.data;
                    }
                },
                selectEntity: (entity, select) => {
                    barChart.selectEntity(entity, select);
                    return chart
                },
                repaint: () => barChart.repaint()
            };
            return chart;
        };
    })();
</script>