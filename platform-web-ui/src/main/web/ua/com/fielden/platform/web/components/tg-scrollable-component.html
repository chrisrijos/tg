<link rel="import" href="/resources/polymer/polymer/polymer.html">
<link rel="import" href="/resources/polymer/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="/app/tg-app-config.html">

<!-- Generic component for scrollable container with bottom / top shadows. The usage of this component should be relatively or absolutely positioned. -->
<!-- --tg-scrollable-layout mixin can be used to customise layout and styles of scrollable content.  -->
<dom-module id="tg-scrollable-component">
    <style>
        :host {
            @apply(--layout-vertical);

        }
        #scrollablePanel {
            overflow: auto;
            @apply(--tg-scrollable-layout);
        }
        .webkit-scroll-inertia {
            -webkit-overflow-scrolling: touch;
        }
        #shadowContainer {
            pointer-events: none;
        }
    </style>
    <template>
        <div id="scrollablePanel" on-scroll="_contentScrolled" class="webkit-scroll-inertia">
            <content></content>
        </div>
        <div id="shadowContainer" class="fit"></div>
        <tg-app-config id="appConfig"></tg-app-config>
    </template>
</dom-module>

<script>
    Polymer({
        is: 'tg-scrollable-component',

        behaviors: [Polymer.IronResizableBehavior],

        attached: function () {
            this._waitForDimensions(0);
        },

        _waitForDimensions: function (time) {
            const self = this;
            self.async(function () {
                // in case where dimensions are not empty and were not changed from last _waitForDimensions call then need to invoke resize event and assign resize listener
                // this will trigger repaint of shadow after inner content re-flow will be completed (for e.g. tg-flex-layout has very dynamic nature, its height keeps reducing until re-flow is finished)
                if (self.$.scrollablePanel.offsetWidth && self.$.scrollablePanel.offsetHeight && self._dimensionNotChanged() >= 1) {
                    self.addEventListener("iron-resize", this._resizeEventListener.bind(this));
                    self._resizeEventListener();
                } else {
                    self._waitForDimensions(100);
                }
            }, time);
        },
        
        _dimensionNotChanged: function () {
            if (this.$.scrollablePanel.offsetWidth === this.oldWidth && this.$.scrollablePanel.offsetHeight === this.oldHeight) {
                this._count += 1;
            } else {
                this._count = 0;
            }
            this.oldWidth = this.$.scrollablePanel.offsetWidth;
            this.oldHeight = this.$.scrollablePanel.offsetHeight;
            return this._count;
        },
        
        _resizeEventListener: function (event, details) {
            this._contentScrolled();
            
            if (this.$.appConfig.mobile === true && this.$.appConfig.iPhoneOs()) { // TODO perhaps MacOs webkit browsers are also affected, then it needs to be fixed here too
                // In webkit-based browsers we use '-webkit-overflow-scrolling: touch' css fix to enable scroll inertia (all other browsers implement that natively).
                // However, this causes completely broken scrolling in cases where inner content changes its sizes.
                // Specifically the size change should be following: at the beginng the content becomes small and non-scrollable and then, again, big and scrollable.
                // See this post http://patrickmuff.ch/blog/2014/10/01/how-we-fixed-the-webkit-overflow-scrolling-touch-bug-on-ios/ and its comments for more information.
                // Also this post http://jstn.name/bug-fix-for-overflow-scrolling-on-orientation-change/ helps too.
                this.$.scrollablePanel.classList.remove('webkit-scroll-inertia');
                this.async(function () {
                    this.$.scrollablePanel.classList.add('webkit-scroll-inertia');
                }.bind(this), 200); // need magic async and wait at least 200 ms (this works on iOs 11.3 Safari 11.0)
            }
        },
        
        _contentScrolled: function (e) {
            const scrollTarget = this.$.scrollablePanel;
            const shadowTarget = this.$.shadowContainer;
            if (scrollTarget) {
                let shadowStyle = "";
                if (scrollTarget.scrollTop) {
                    shadowStyle += "inset 0 3px 6px -2px rgba(0,0,0,0.7)";
                }
                if (scrollTarget.scrollTop + scrollTarget.offsetHeight < scrollTarget.scrollHeight) {
                    shadowStyle += (shadowStyle ? ", " : "") + "inset 0 -3px 6px -2px rgba(0,0,0,0.7)";
                }
                if (shadowStyle) {
                    shadowTarget.style.boxShadow = shadowStyle;
                } else {
                    shadowTarget.style.removeProperty('box-shadow');
                }
            }
        }
    });
</script>