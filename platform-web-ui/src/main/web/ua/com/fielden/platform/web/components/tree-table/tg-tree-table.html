<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/components/tg-tooltip-behavior.html">
<link rel="import" href="/resources/components/tree-table/tg-tree-table-cell.html">

<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="tg-tree-table">
    <template>
        <style>
            /* Container styles*/
            :host {
                @apply(--layout-vertical);
            }
            paper-material {
                margin: 10px;
            }
            .data-table {
                background-color: white;
                border-radius: 2px;
                position: relative;
            }
            #scrollContainer {
                padding-bottom: 15px;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
            }
            #lockContainer {
                pointer-events: none;
            }
            /*Table elements styles*/
            .tree-table-header-row {
                font-size: 0.9rem;
                font-weight: 400;
                min-height: 3rem;
                color: #757575;
                -webkit-font-smoothing: antialiased;
                text-rendering: optimizeLegibility;
                min-width: fit-content;
                flex-grow: 0;
                flex-shrink: 0;
            }
            .tree-table-data-row {
                font-size: 1rem;
                font-weight: 400;
                color: #212121;
                height: 1.5rem;
                border-top: 1px solid #e3e3e3;
                -webkit-font-smoothing: antialiased;
                text-rendering: optimizeLegibility;
                min-width: fit-content;
                flex-grow: 0;
                flex-shrink: 0;
            }
            .header-column {
                box-sizing: border-box;
                @apply(--layout-center);

            }
            .header-column[column-type=hierarchy] {
                padding: 0 0.6rem;
            }
            .header-column[column-type=regular] {
                padding: 0.6rem;
                writing-mode: vertical-lr;
                transform: rotate(180deg);
                @apply(--layout-start-justified);

            }
            .table-data-cell {
                box-sizing: border-box;
                @apply(--layout-horizontal);
                @apply(--layout-center);
            }
            .table-data-cell[column-type=regular] {
                padding: 0 0.6rem;
                @apply(--layout-center-justified);
            }
            .table-data-cell[column-type=hierarchy] {
                padding-right: 0.6rem;
                @apply(--layout-center);
            }
            /* Miscelenia styles */
            .truncate {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        </style>
        <content id="column_selector" select="tg-tree-table-property-column" hidden></content>

        <paper-material elevation="1" class="layout vertical">
            <div id="elementToFocus" class="layout vertical flex data-table" tabindex="0">

                <div id="baseContainer" class="relative layout horizontal flex">
                    <!--Scroll Container-->
                    <div id="scrollContainer" class="layout vertical flex">
                        <!--Tree table header-->
                        <div class="layout horizontal tree-table-header-row">
                            <template is="dom-repeat" items="[[columns]]">
                                <div class="layout horizontal header-column" hidden$="[[!item.visible]]" column-type$="[[_columnType(item)]]" tooltip-text$="[[item.columnDesc]]" style$="[[_calcColumnStyle(item, item.width, item.growFactor)]]">
                                    <div class="truncate">[[item.columnTitle]]</div>
                                </div>
                            </template>
                        </div>
                        <!--table body-->
                        <template is="dom-repeat" items="[[treeModel]]" as="treeEntity" index-as="treeEntityIndex">
                            <div class="layout horizontal tree-table-data-row" hidden$="[[_isEntityHidden(treeEntity.parent.collapsed, treeEntity.visible)]]" over$="[[treeEntity.over]]" on-mouseenter="_mouseRowEnter" on-mouseleave="_mouseRowLeave">
                                <template is="dom-repeat" items="[[columns]]" as="column">
                                    <tg-tree-table-cell class="table-data-cell" column-type$="[[_columnType(column)]]" hidden$="[[!column.visible]]" column="[[column]]" highlight="[[treeEntity.highlight]]" entity-index="[[treeEntityIndex]]" entity="[[treeEntity]]" style$="[[_calcColumnStyle(column, column.width, column.growFactor)]]"></tg-tree-table-cell>
                                    <!--tooltip-text$="[[_getTooltip(treeEntity.entity, column)]]"-->
                                </template>
                            </div>
                        </template>
                        <!-- Scrollable container goes here -->
                    </div>
                    <!--Fixed Container-->
                    <div id="lockContainer" class="fit" style="overflow:hidden">

                    </div>
                </div>
            </div>
        </paper-material>
    </template>
    <script>
        (function () {
            'use strict'
            const removeColumn = function (column, fromColumns) {
                const index = fromColumns.indexOf(column);
                if (index >= 0) {
                    fromColumns.splice(index, 1);
                    return true;
                }
                return false;
            };
            Polymer({
                is: 'tg-tree-table',

                behaviors: [Polymer.IronResizableBehavior, Polymer.TgBehaviors.TgTooltipBehavior],

                properties: {
                    entities: {
                        type: Array,
                        observer: "_entitiesChanged"
                    },
                    columns: Array,
                    hierarchyColumn: Object
                },

                listeners: {
                    "tg-tree-toggle-collapse-state": "_toggleTreeEntityToggleState"
                },

                ready: function () {
                    //Initiates columns
                    this.columns = [];
                    this.hierarchyColumn = null;
                    //Observe column DOM changes
                    Polymer.dom(this.$.column_selector).observeNodes(info => {
                        this._columnDomChanged(info.addedNodes, info.removedNodes);
                    });
                },

                //////////////////////////Security token filtering related functions//////////////////////////////
                filterTokens: function (text) {
                    if (this.treeModel) {
                        this._expandAll();
                        this.treeModel.forEach(treeEntity => {
                            if (treeEntity.entity.get("title").toLowerCase().search(text.toLowerCase()) >= 0) {
                                this.set("treeModel." + (treeEntity.entityIndex) + ".visible", true);
                                this._makeParentVisible(treeEntity);
                                this.set("treeModel." + (treeEntity.entityIndex) + ".highlight", text ? true: false);
                            } else {
                                this.set("treeModel." + (treeEntity.entityIndex) + ".visible", false);
                                this.set("treeModel." + (treeEntity.entityIndex) + ".highlight", false);
                            }
                        });
                    }
                },

                _makeParentVisible: function (entity) {
                    let parent = entity.parent;
                    while (parent) {
                        this.set("treeModel." + (parent.entityIndex) + ".visible", true);
                        parent = parent.parent;
                    }
                },
                
                _expandAll: function () {
                    if (this.treeModel) {
                        this.treeModel.forEach(treeEntity => {
                            this.set("treeModel." + (treeEntity.entityIndex) + ".collapsed", !(treeEntity.entity.children && treeEntity.entity.children.length > 0));
                        });
                    }
                },
                
                //////////////////////////User role filtering related functions//////////////////////////////
                filterRoles: function (text) {
                    if (this.columns) {
                        this.columns.forEach((column, index) => {
                            if (!column.isHierarchyProperty()) {
                                if (column.columnTitle.toLowerCase().search(text.toLowerCase()) >= 0) {
                                    this.set("columns." + index + ".visible", true);
                                } else {
                                    this.set("columns." + index + ".visible", false);
                                }
                            }
                        });
                    }
                },
                
                ///////////////////Observer related functions//////////////////////////////
                _entitiesChanged: function (newEntities, oldEntities) {
                    const tempTreeModel = []
                    this._pushChildren(newEntities, tempTreeModel);
                    this.treeModel = tempTreeModel;
                },

                _pushChildren: function (children, toList, parent) {
                    const childrenList = children.map(child => {
                        const treeEntity = {
                            over: false,
                            entity: child,
                            entityIndex: toList.length, 
                            parent: parent ? parent: {collapsed: false},
                            collapsed: !!(child.children && child.children.length > 0),
                            visible: true,
                            highlight: false
                        };
                        toList.push(treeEntity);
                        if (child.children && child.children.length > 0) {
                            this._pushChildren(child.children, toList, treeEntity);
                        }
                        return treeEntity;
                    });
                    if (parent) {
                        parent.children = childrenList;
                    }
                },

                _columnDomChanged: function (addedColumns, removedColumns) {
                    const columnsCopy = this.columns.slice();
                    let columnsChanged = false;
                    removedColumns.forEach(col => {
                        columnsChanged = removeColumn(col, columnsCopy);
                    });

                    addedColumns.forEach(col => {
                        const index = this.columns.findIndex(column => column.property === col.property);
                        if (index < 0) {
                            columnsCopy.push(col);
                            columnsChanged = true;
                        }
                    });
                    if (columnsChanged) {
                        this.columns = columnsCopy;
                    }
                },

                //////////////////////Event listeners/////////////////////
                _mouseRowEnter: function (event, detail) {
                    const index = event.model.treeEntityIndex;
                    this.set("treeModel." + index + ".over", true);
                },

                _mouseRowLeave: function (event, detail) {
                    const index = event.model.treeEntityIndex;
                    this.set("treeModel." + index + ".over", false);
                },

                _toggleTreeEntityToggleState: function (e) {
                    const entityIndex = e.detail.entityIndex;
                    const newState = e.detail.state;
                    const entity = e.detail.entity;
                    this.set("treeModel." + entityIndex + ".collapsed", newState);
                    if (entity.children && entity.children.length > 0) {
                        entity.children.forEach((child, childIndex) => this.notifyPath("treeModel." + (entityIndex + 1 + childIndex) + ".parent.collapsed", newState));
                    }
                },

                ////////////////////////Style calculation methods.//////////////////////////////////////
                _calcColumnStyle: function (column, columnWidth, columnGrowFactor) {
                    let colStyle = "min-width: " + columnWidth + "px;" + "width: " + columnWidth + "px;"
                    if (columnGrowFactor === 0) {
                        colStyle += "flex-grow: 0;flex-shrink:0;";
                    } else {
                        colStyle += "flex-grow: " + columnGrowFactor + ";";
                    }
                    return colStyle;
                },
                
                _isEntityHidden: function (parentCollapsed, isVisible) {
                    return parentCollapsed || !isVisible;
                },

                _columnType: function (item) {
                    return item.isHierarchyProperty() ? "hierarchy" : "regular";
                },
            });
        })();
    </script>
</dom-module>