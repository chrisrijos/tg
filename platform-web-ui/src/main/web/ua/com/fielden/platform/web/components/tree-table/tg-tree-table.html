<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/components/tg-tooltip-behavior.html">
<link rel="import" href="/resources/components/tree-table/tg-tree-table-row.html">

<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="tg-tree-table">
    <template>
        <style>
            /* Container styles*/
            :host {
                @apply(--layout-vertical);
            }
            #elementToFocus {
                margin: 10px;
            }
            .data-table {
                background-color: white;
                border-radius: 2px;
                position: relative;
            }
            #scrollContainer {
                padding-bottom: 15px;
                -webkit-overflow-scrolling: touch;
                overflow: auto;
            }
            #lockContainer {
                pointer-events: none;
            }
            #topShadow {
                box-shadow: 0px 3px 6px -2px rgba(0,0,0,0.7);
                pointer-events: none;
            }
            #bottomShadow {
                top: 100%;
                height: 20px;
                left: 0;
                right: 0;
                box-shadow: 0px -3px 6px -2px rgba(0,0,0,0.7);
                pointer-events: none;
            }
            /*Table elements styles*/
            .tree-table-header-row {
                font-size: 0.9rem;
                font-weight: 400;
                min-height: 3rem;
                color: #757575;
                -webkit-font-smoothing: antialiased;
                text-rendering: optimizeLegibility;
                min-width: fit-content;
                flex-grow: 0;
                flex-shrink: 0;
            }
            .header-column {
                box-sizing: border-box;
                @apply(--layout-center);

            }
            .header-column[column-type=hierarchy] {
                padding: 0 0.6rem;
            }
            .header-column[column-type=regular] {
                padding: 0.6rem;
                writing-mode: vertical-lr;
                transform: rotate(180deg);
                @apply(--layout-start-justified);

            }
            /* Miscelenia styles */
            .truncate {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .absolute,
            .absolutely-white {
                position: absolute;
            }   
            .absolutely-white {
                background-color: white;
                pointer-events: auto;
            }
        </style>
        <content id="column_selector" select="tg-tree-table-property-column" hidden></content>

        <div id="elementToFocus" class="layout vertical flex data-table">

            <div id="baseContainer" class="relative layout horizontal flex">
                <!--Scroll Container-->
                <div id="scrollContainer" on-scroll="_handleScrollEvent" class="layout vertical flex">
                    <!--Tree table header-->
                    <div class="layout horizontal tree-table-header-row">
                        <div class="layout horizontal header-column" column-type="hierarchy" tooltip-text$="[[hierarchyColumn.columnDesc]]" style$="[[_calcColumnStyle(hierarchyColumn, hierarchyColumn.width, hierarchyColumn.growFactor)]]">
                                <div class="truncate">[[hierarchyColumn.columnTitle]]</div>
                        </div>
                        <template is="dom-repeat" items="[[columns]]">
                            <div class="layout horizontal header-column" hidden$="[[!item.visible]]" column-type="regular" tooltip-text$="[[item.columnDesc]]" style$="[[_calcColumnStyle(item, item.width, item.growFactor)]]">
                                <div class="truncate">[[item.columnTitle]]</div>
                            </div>
                        </template>
                    </div>
                    <!--table body-->
                    <template is="dom-repeat" items="[[treeModel]]" as="treeEntity" index-as="treeEntityIndex">
                        <tg-tree-table-row entity="[[treeEntity]]" hierarchy-column="[[hierarchyColumn]]" columns="[[columns]]"></tg-tree-table-row>
                    </template>
                    <!-- Scrollable container goes here -->
                </div>
                <!--Fixed Container-->
                <div id="lockContainer" class="fit" style="overflow:hidden">
                    <div id="topLockContainer" class="absolutely-white layout horizontal tree-table-header-row" style$="[[_calculateTopLockPanelStyle(_scrollLeft)]]">
                        <div id="topShadow" class="fit" hidden$="[[!_showTopShadow]]"></div>
                        <div class="layout horizontal header-column" column-type="hierarchy" tooltip-text$="[[hierarchyColumn.columnDesc]]" style$="[[_calcColumnStyle(hierarchyColumn, hierarchyColumn.width, hierarchyColumn.growFactor)]]">
                                <div class="truncate">[[hierarchyColumn.columnTitle]]</div>
                        </div>
                        <template is="dom-repeat" items="[[columns]]">
                            <div class="layout horizontal header-column" hidden$="[[!item.visible]]" column-type="regular" tooltip-text$="[[item.columnDesc]]" style$="[[_calcColumnStyle(item, item.width, item.growFactor)]]">
                                <div class="truncate">[[item.columnTitle]]</div>
                            </div>
                        </template>
                    </div>
                    <div id="bottomShadow" class="absolute" hidden$="[[!_showBottomShadow]]"></div>
                </div>
            </div>
        </div>
    </template>
    <script>
        (function () {
            'use strict'
            Polymer({
                is: 'tg-tree-table',

                behaviors: [Polymer.IronResizableBehavior, Polymer.TgBehaviors.TgTooltipBehavior],
                
                listeners: {"tg-tree-toggle-collapse-state": "_toggleTreeEntityToggleState"},

                properties: {
                    entities: {
                        type: Array,
                        observer: "_entitiesChanged"
                    },
                    hierarchyColumn: Object,
                    columns: Array,
                    
                    //Properties for managing shadow visibility
                    _showTopShadow: Boolean,
                    _showBottomShadow: Boolean,
                    
                    //Properties for managing lock container scrolling
                    _scrollLeft: Number,
                    _scrollTop: Number
                },

                ready: function () {                    
                    //Initialising event listeners.
                    this.addEventListener("iron-resize", this._resizeEventListener.bind(this));
                },
                
                /////////////////////////////Event listeners////////////////////////////////////
                _toggleTreeEntityToggleState: function (e) {
                    this._updateTableSizeAsync();
                },
                
                /**
                 * Resize event handler that adjusts the lock container size and position.
                 */
                _resizeEventListener: function (event, details) {
                    this.$.lockContainer.style.bottom = this._calcHorizontalScrollBarHeight() + "px";
                    this.$.lockContainer.style.right = this._calcVerticalScrollBarWidth() + "px";
                    this._handleScrollEvent();
                },
                
                /**
                 * Calculates the vertical scrollbar width.
                 */
                _calcVerticalScrollBarWidth: function () {
                    return this.$.scrollContainer.offsetWidth - this.$.scrollContainer.clientWidth;
                },

                /**
                 * Calculates the horizontal scrollbar height.
                 */
                _calcHorizontalScrollBarHeight: function () {
                    return this.$.scrollContainer.offsetHeight - this.$.scrollContainer.clientHeight;
                },

                /**
                 * Scrolling related functions.
                 */
                _handleScrollEvent: function () {
                    this._scrollLeft = this.$.scrollContainer.scrollLeft;
                    this._scrollTop = this.$.scrollContainer.scrollTop;
                    this._updateShadows();
                },
                
                _updateShadows: function () {
                    this._showTopShadow = this.$.scrollContainer.scrollTop !== 0;
                    this._showBottomShadow = (this.$.scrollContainer.clientHeight + this.$.scrollContainer.scrollTop) !== this.$.scrollContainer.scrollHeight;
                },
                
                /**
                 * invokes resize event listener on asynch.
                 */
                _updateTableSizeAsync: function () {
                    this.async(function () {
                        this._resizeEventListener();
                    }.bind(this), 1);
                },

                //////////////////////////Security token filtering related functions//////////////////////////////
                filterTokens: function (text) {
                    if (this.treeModel) {
                        this._expandAll();
                        this._filterTreeModel(text, this.treeModel);
                        this._updateTableSizeAsync();
                    }
                },

                _filterTreeModel: function (text, treeModel) {
                    treeModel.forEach(treeEntity => {
                        if (treeEntity.entity.get("title").toLowerCase().search(text.toLowerCase()) >= 0) {
                            this._setVisible(treeEntity, true);
                            this._makeParentVisible(treeEntity);
                            this._setHighlight(treeEntity, text ? true : false);
                        } else {
                            this._setVisible(treeEntity, false);
                            this._setHighlight(treeEntity, false);
                        }
                        if (treeEntity.children && treeEntity.children.length > 0) {
                            this._filterTreeModel(text, treeEntity.children);
                        }
                    });
                },

                _setHighlight: function (treeEntity, highlight) {
                    treeEntity.highlighted = highlight;
                    if (treeEntity.highlightFunctions) {
                        treeEntity.highlightFunctions.forEach(highlightFunction => highlightFunction(highlight));
                    }
                },

                _setVisible: function (treeEntity, visible) {
                    treeEntity.entity.$visible = visible;
                    if (treeEntity.visibilityFunctions) {
                        treeEntity.visibilityFunctions.forEach(visibilityFunction => visibilityFunction(visible));
                    }
                },

                _makeParentVisible: function (entity) {
                    let parent = entity.parent;
                    while (parent) {
                        this._setVisible(parent, true);
                        parent = parent.parent;
                    }
                },

                _expandAll: function () {
                    if (this.treeModel) {
                        this.treeModel.forEach(treeEntity => {
                            this._expandEntity(treeEntity);
                        });
                    }
                },
                
                _expandEntity: function(treeEntity) {
                    if (treeEntity.children && treeEntity.children.length > 0) {
                        treeEntity.collapsed = false;
                        if (treeEntity.expandFunctions) {
                            treeEntity.expandFunctions.forEach(expandFunction => expandFunction());
                        }
                        treeEntity.children.forEach(child => this._expandEntity(child));
                    }
                },

                //////////////////////////User role filtering related functions//////////////////////////////
                filterRoles: function (text) {
                    if (this.columns) {
                        this.columns.forEach((column, index) => {
                            if (column.columnTitle.toLowerCase().search(text.toLowerCase()) >= 0) {
                                this.set("columns." + index + ".visible", true);
                            } else {
                                this.set("columns." + index + ".visible", false);
                            }
                        });
                        this._updateTableSizeAsync();
                    }
                },

                ///////////////////Observer related functions//////////////////////////////
                _entitiesChanged: function (newEntities, oldEntities) {
                    this.treeModel = this._createTreeModel(newEntities);
                    this._updateTableSizeAsync();
                },

                _createTreeModel: function (children, parent) {
                    const childrenList = children && children.map(child => {
                        const treeEntity = {
                            over: false,
                            collapsed: true,
                            highlighted: false,
                            visible: true,
                            entity: child,
                            parent: parent
                        };
                        if (child.children && child.children.length > 0) {
                            treeEntity.children = this._createTreeModel(child.children, treeEntity);
                        }
                        return treeEntity;
                    });
                    return childrenList;
                },

                ////////////////////////Style calculation methods.//////////////////////////////////////
                _calcColumnStyle: function (column, columnWidth, columnGrowFactor) {
                    let colStyle = "min-width: " + columnWidth + "px;" + "width: " + columnWidth + "px;"
                    if (columnGrowFactor === 0) {
                        colStyle += "flex-grow: 0;flex-shrink:0;";
                    } else {
                        colStyle += "flex-grow: " + columnGrowFactor + ";";
                    }
                    return colStyle;
                },

                _calculateTopLockPanelStyle: function(_scrollLeft) {
                    return "top:0;right:0;left:-" + _scrollLeft + "px;"; 
                }
            });
        })();
    </script>
</dom-module>