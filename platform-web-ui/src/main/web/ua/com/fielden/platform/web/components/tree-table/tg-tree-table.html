<link rel="import" href="/resources/polymer/polymer/polymer.html">

<link rel="import" href="/resources/components/tg-tooltip-behavior.html">
<link rel="import" href="/resources/components/tree-table/tg-tree-table-row.html">

<link rel="import" href="/resources/polymer/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="tg-tree-table">
    <template>
        <style>
            /* Container styles*/
            :host {
                @apply(--layout-vertical);

            }
            #elementToFocus {
                margin: 10px;
            }
            .data-table {
                background-color: white;
                border-radius: 2px;
                position: relative;
            }
            #scrollContainer {
                padding-bottom: 15px;
                -webkit-overflow-scrolling: touch;
                overflow: auto;
            }
            #lockContainer {
                pointer-events: none;
            }
            /*Table elements styles*/
            .tree-table-header-row {
                font-size: 0.9rem;
                font-weight: 400;
                min-height: 3rem;
                color: #757575;
                -webkit-font-smoothing: antialiased;
                text-rendering: optimizeLegibility;
                min-width: fit-content;
                flex-grow: 0;
                flex-shrink: 0;
            }
            .header-column {
                box-sizing: border-box;
                @apply(--layout-center);

            }
            .header-column[column-type=hierarchy] {
                padding: 0 0.6rem;
            }
            .header-column[column-type=regular] {
                padding: 0.6rem;
                writing-mode: vertical-lr;
                transform: rotate(180deg);
                @apply(--layout-start-justified);

            }
            /* Miscelenia styles */
            .truncate {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        </style>
        <content id="column_selector" select="tg-tree-table-property-column" hidden></content>

        <div id="elementToFocus" class="layout vertical flex data-table" tabindex="0">

            <div id="baseContainer" class="relative layout horizontal flex">
                <!--Scroll Container-->
                <div id="scrollContainer" class="layout vertical flex">
                    <!--Tree table header-->
                    <div class="layout horizontal tree-table-header-row">
                        <template is="dom-repeat" items="[[columns]]">
                            <div class="layout horizontal header-column" hidden$="[[!item.visible]]" column-type$="[[_columnType(item)]]" tooltip-text$="[[item.columnDesc]]" style$="[[_calcColumnStyle(item, item.width, item.growFactor)]]">
                                <div class="truncate">[[item.columnTitle]]</div>
                            </div>
                        </template>
                    </div>
                    <!--table body-->
                    <template is="dom-repeat" items="[[treeModel]]" as="treeEntity" index-as="treeEntityIndex">
                        <tg-tree-table-row entity="[[treeEntity]]" columns="[[columns]]" highlight="[[treeEntity.highlight]]"></tg-tree-table-row>
                    </template>
                    <!-- Scrollable container goes here -->
                </div>
                <!--Fixed Container-->
                <div id="lockContainer" class="fit" style="overflow:hidden">

                </div>
            </div>
        </div>
    </template>
    <script>
        (function () {
            'use strict'
            const removeColumn = function (column, fromColumns) {
                const index = fromColumns.indexOf(column);
                if (index >= 0) {
                    fromColumns.splice(index, 1);
                    return true;
                }
                return false;
            };
            Polymer({
                is: 'tg-tree-table',

                behaviors: [Polymer.IronResizableBehavior, Polymer.TgBehaviors.TgTooltipBehavior],

                properties: {
                    entities: {
                        type: Array,
                        observer: "_entitiesChanged"
                    },
                    columns: Array,
                    hierarchyColumn: Object
                },

                ready: function () {
                    //Initiates columns
                    this.columns = [];
                    this.hierarchyColumn = null;
                    //Observe column DOM changes
                    Polymer.dom(this.$.column_selector).observeNodes(info => {
                        this._columnDomChanged(info.addedNodes, info.removedNodes);
                    });
                },

                //////////////////////////Security token filtering related functions//////////////////////////////
                filterTokens: function (text) {
                    if (this.treeModel) {
                        this._expandAll();
                        this._filterTreeModel(text, this.treeModel);
                    }
                },

                _filterTreeModel: function (text, treeModel) {
                    treeModel.forEach(treeEntity => {
                        if (treeEntity.entity.get("title").toLowerCase().search(text.toLowerCase()) >= 0) {
                            this._setVisible(treeEntity, true);
                            this._makeParentVisible(treeEntity);
                            this._setHighlight(treeEntity, text ? true : false);
                        } else {
                            this._setVisible(treeEntity, false);
                            this._setHighlight(treeEntity, false);
                        }
                        if (treeEntity.children && treeEntity.children.length > 0) {
                            this._filterTreeModel(text, treeEntity.children);
                        }
                    });
                },

                _setHighlight: function (treeEntity, highlight) {
                    if (treeEntity.highlightFunctions) {
                        treeEntity.highlightFunctions.forEach(highlightFunction => highlightFunction(highlight));
                    }
                },

                _setVisible: function (treeEntity, visible) {
                    if (treeEntity.visibilityFunctions) {
                        treeEntity.visibilityFunctions.forEach(visibilityFunction => visibilityFunction(visible));
                    }
                },

                _makeParentVisible: function (entity) {
                    let parent = entity.parent;
                    while (parent) {
                        this._setVisible(parent, true);
                        parent = parent.parent;
                    }
                },

                _expandAll: function () {
                    if (this.treeModel) {
                        this.treeModel.forEach(treeEntity => {
                            if (treeEntity.expandFunctions) {
                                treeEntity.expandFunctions.forEach(expandFunction => expandFunction());
                            }
                        });
                    }
                },

                //////////////////////////User role filtering related functions//////////////////////////////
                filterRoles: function (text) {
                    if (this.columns) {
                        this.columns.forEach((column, index) => {
                            if (!column.isHierarchyProperty()) {
                                if (column.columnTitle.toLowerCase().search(text.toLowerCase()) >= 0) {
                                    this.set("columns." + index + ".visible", true);
                                } else {
                                    this.set("columns." + index + ".visible", false);
                                }
                            }
                        });
                    }
                },

                ///////////////////Observer related functions//////////////////////////////
                _entitiesChanged: function (newEntities, oldEntities) {
                    this.treeModel = this._createTreeModel(newEntities);
                },

                _createTreeModel: function (children, parent) {
                    const childrenList = children && children.map(child => {
                        const treeEntity = {
                            over: false,
                            entity: child,
                            parent: parent
                        };
                        if (child.children && child.children.length > 0) {
                            treeEntity.children = this._createTreeModel(child.children, treeEntity);
                        }
                        return treeEntity;
                    });
                    return childrenList;
                },

                _columnDomChanged: function (addedColumns, removedColumns) {
                    const columnsCopy = this.columns.slice();
                    let columnsChanged = false;
                    removedColumns.forEach(col => {
                        columnsChanged = removeColumn(col, columnsCopy);
                    });

                    addedColumns.forEach(col => {
                        const index = this.columns.findIndex(column => column.property === col.property);
                        if (index < 0) {
                            columnsCopy.push(col);
                            columnsChanged = true;
                        }
                    });
                    if (columnsChanged) {
                        this.columns = columnsCopy;
                    }
                },

                ////////////////////////Style calculation methods.//////////////////////////////////////
                _calcColumnStyle: function (column, columnWidth, columnGrowFactor) {
                    let colStyle = "min-width: " + columnWidth + "px;" + "width: " + columnWidth + "px;"
                    if (columnGrowFactor === 0) {
                        colStyle += "flex-grow: 0;flex-shrink:0;";
                    } else {
                        colStyle += "flex-grow: " + columnGrowFactor + ";";
                    }
                    return colStyle;
                },

                _columnType: function (item) {
                    return item.isHierarchyProperty() ? "hierarchy" : "regular";
                }
            });
        })();
    </script>
</dom-module>